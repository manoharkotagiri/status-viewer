import { Component, Prop, Element, State, Event, Method, Watch, forceUpdate, h } from "@stencil/core";
import { getHostAttributes, getSpreadableAttributes, setDefaultHostAttributes, setStyleAttribute } from "../../utils/attributes/attributeUtils";
import { registerAttributeObserver, registerSlotObserver } from "../../utils/registerObserver";
import { isTruthyOrZero } from "../../utils/objectUtils";
/**
 * Select lets users choose from a list of items. It is best used when you want to select an item from a list of 5&ndash;15 items.
 *
 * > **Note:** `<kds-select />` is a [primitive web component](primitives/) that accepts all props listed below and any attributes prefixed with `inner-`.
 * `inner-*` attributes are stripped of their `inner-` prefix and placed onto the native `<select>` element.
 *
 * ```Message { "props": { "kind": "warning", "className": "mb-16" } }
 * **Angular Consumers:** This component requires at least version 1.0.0 of kds-stencil-accessors for use with Angular Forms.
 * Refer to our [getting started documentation](/stencil/getting-started#Angular%20Accessors) for installation and usage instructions.
 * ```
 */
export class KdsSelect {
  constructor() {
    /** Applies the compact size. */
    this.compact = false;
    this.onChildrenChanged = () => {
      this.length = this.selectElement.length;
      const options = this.getOptionChildren(this.selectElement);
      this.setOptionValues(options);
    };
    this.onInput = (ev) => {
      const select = ev.target;
      if (select) {
        this.value = select.value;
        this.selectedIndex = select.selectedIndex;
      }
    };
  }
  setNativeSelectedIndex() {
    if (this.selectElement) {
      this.selectElement.selectedIndex = this.selectedIndex;
      this.value = this.selectElement.value;
    }
  }
  setNativeValue() {
    if (this.selectElement) {
      this.selectElement.value = this.value;
      this.selectedIndex = this.selectElement.selectedIndex;
    }
  }
  componentWillLoad() {
    this.observer = registerAttributeObserver(this);
    this.slotObserver = registerSlotObserver(this, (mutations) => {
      mutations.find(({ addedNodes }) => {
        const nodes = Array.from(addedNodes);
        return nodes.find(node => node.nodeName === "OPTION");
      }) && forceUpdate(this);
    });
    this.selectObserver = new MutationObserver(this.onChildrenChanged);
    this.innerAttrs = getHostAttributes(this.hostEl);
    setDefaultHostAttributes(this.hostEl);
    const options = this.getOptionChildren(this.hostEl);
    /** When using <slot /> for options, selectedIndex defaults to last option.
     * If no initial provided options are selected, we need to reset the selectedIndex to 0
     */
    this.shouldReset = !Boolean(options.find((option) => option.selected) ||
      // explicitly check for `undefined` because `0` was incorrectly being flagged
      // as needing to be reset
      this.selectedIndex !== undefined);
    this.selectedIndex = this.shouldReset ? 0 : this.selectedIndex;
    this.setOptionValues(options);
  }
  componentDidLoad() {
    this.observer.observe(this.hostEl, { attributes: true });
    this.slotObserver.observe(this.hostEl, {
      characterData: true,
      childList: true
    });
    this.selectObserver.observe(this.selectElement, {
      characterData: true,
      childList: true
    });
    this.ready.emit(this.selectElement);
    this.hostEl.nativeElement = this.selectElement;
    this.selectElement.selectedIndex = isTruthyOrZero(this.selectedIndex)
      ? this.selectedIndex
      : this.selectElement.selectedIndex;
    this.value = this.value || this.selectElement.value;
    this.selectElement.value = this.value;
    // In unit tests, this.selectElement.length can be undefined
    // so let's add a backup length by grabbing the children length
    this.length =
      this.selectElement.length ||
        this.getOptionChildren(this.selectElement).length;
  }
  componentShouldUpdate(newValue, oldValue, propName) {
    switch (propName) {
      case "length":
        return oldValue !== undefined && oldValue !== newValue;
      case "value":
        return (oldValue !== undefined &&
          oldValue !== newValue &&
          this.selectElement.value !== newValue);
      case "selectedIndex":
        return (oldValue !== undefined &&
          oldValue !== newValue &&
          this.selectElement.selectedIndex !== newValue);
      default:
        return true;
    }
  }
  componentDidUpdate() {
    this.value = this.selectElement.value;
    this.selectedIndex = this.selectElement.selectedIndex;
  }
  disconnectedCallback() {
    this.observer && this.observer.disconnect();
    this.slotObserver && this.slotObserver.disconnect();
  }
  createSelectElementRef(el) {
    if (el) {
      setStyleAttribute(el, this.innerAttrs);
      this.selectElement = el;
    }
  }
  getOptionChildren(el) {
    return Array.from(el.getElementsByTagName("option"));
  }
  /**
   * Returns the native `<select>` element used under the hood.
   */
  getNativeElement() {
    return Promise.resolve(this.selectElement);
  }
  /**
   * In IE11, setting a value on a <select> element requires an option have its value explicitly set.
   * Here, we iterate over the children and set their value to their innerText if no value is already defined.
   */
  setOptionValues(options) {
    options.forEach((option) => {
      option.value = option.value || option.textContent;
    });
  }
  render() {
    return (h("select", Object.assign({}, getSpreadableAttributes(this.innerAttrs), { autoFocus: this.autofocus, disabled: this.disabled, form: this.form, name: this.name, required: this.required, class: {
        "kds-Select": true,
        "kds-Select--compact": this.compact,
        [this.innerAttrs.class]: this.innerAttrs.class
      }, ref: (el) => this.createSelectElementRef(el), onInput: this.onInput }),
      h("slot", null)));
  }
  static get is() { return "kds-select"; }
  static get originalStyleUrls() { return {
    "$": ["kds-select.css"]
  }; }
  static get styleUrls() { return {
    "$": ["kds-select.css"]
  }; }
  static get properties() { return {
    "compact": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Applies the compact size."
      },
      "attribute": "compact",
      "reflect": false,
      "defaultValue": "false"
    },
    "autofocus": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Takes focus when the form is presented."
      },
      "attribute": "autofocus",
      "reflect": false
    },
    "disabled": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Disables if present."
      },
      "attribute": "disabled",
      "reflect": false
    },
    "form": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Associates a field to a form element."
      },
      "attribute": "form",
      "reflect": false
    },
    "name": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Sets the name."
      },
      "attribute": "name",
      "reflect": false
    },
    "required": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Requires value before submission."
      },
      "attribute": "required",
      "reflect": false
    },
    "value": {
      "type": "string",
      "mutable": true,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Contains the current value."
      },
      "attribute": "value",
      "reflect": false
    },
    "selectedIndex": {
      "type": "number",
      "mutable": true,
      "complexType": {
        "original": "number",
        "resolved": "number",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Reflects the index value of the first selected `<option>` element. The value -1 indicates no element selected."
      },
      "attribute": "selected-index",
      "reflect": false
    },
    "length": {
      "type": "number",
      "mutable": true,
      "complexType": {
        "original": "number",
        "resolved": "number",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Contains the number of `<option>` elements."
      },
      "attribute": "length",
      "reflect": false
    }
  }; }
  static get states() { return {
    "innerAttrs": {}
  }; }
  static get events() { return [{
      "method": "ready",
      "name": "ready",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emits when the component has been loaded. Event's `detail` contains a reference to the inner select element."
      },
      "complexType": {
        "original": "any",
        "resolved": "any",
        "references": {}
      }
    }]; }
  static get methods() { return {
    "getNativeElement": {
      "complexType": {
        "signature": "() => Promise<HTMLSelectElement>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          },
          "HTMLSelectElement": {
            "location": "global"
          }
        },
        "return": "Promise<HTMLSelectElement>"
      },
      "docs": {
        "text": "Returns the native `<select>` element used under the hood.",
        "tags": []
      }
    }
  }; }
  static get elementRef() { return "hostEl"; }
  static get watchers() { return [{
      "propName": "selectedIndex",
      "methodName": "setNativeSelectedIndex"
    }, {
      "propName": "value",
      "methodName": "setNativeValue"
    }]; }
}
