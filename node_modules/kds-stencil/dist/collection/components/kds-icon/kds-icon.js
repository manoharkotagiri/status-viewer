import { Component, Prop, Element, h } from "@stencil/core";
import { getWindow } from "../../utils/windowUtils";
import { colors, inlineSizeMap, sizes } from "./propOpts";
/**
 * Icons provide visual cues that improve the user's ability to scan the experience. They should be used in moderation to represent simple concepts and actions.
 *
 * Each icon is exported as a named web component. e.g. `<kds-icon-account>`, `<kds-icon-add-plus-card>`, etc.
 *
 * By default, icons inherit color. Inline icons are auto-sized to the KDS designated line-height of their supporting text.
 *
 * See: [KDS style guide for Icons](/design/components/icon)
 */
export class KdsIcon {
  constructor() {
    this.trySettingAutoFontSize = (el) => {
      /** If the element is not falsey and the window exists, then ... */
      if (el && getWindow()) {
        /** Get computed styles for host element; */
        const computedStyle = getWindow().getComputedStyle(this.hostEl);
        /** Get just the floating point number value of the computed font-size; */
        const computedFontSizeNum = parseFloat(computedStyle.getPropertyValue("font-size"));
        /** Get the correct class if the font-size is one of KDS designated inline sizes. */
        const autoFontSizeClass = inlineSizeMap[computedFontSizeNum.toFixed(1) // .toFixed(1) to match inlineSizeMap keys
        ];
        /** If autoFontSizeClass was retrieved from inlineSizeMap, then ... */
        if (autoFontSizeClass) {
          const classes = Array.from(el.classList);
          /** Remove all existing inline classes and set new inline class accordingly */
          classes
            .filter(className => className.includes("kds-Icon--inline"))
            .forEach(className => el.classList.remove(className));
          el.classList.add("kds-Icon--inline", autoFontSizeClass);
        }
        else {
          /** Otherwise, ... */
          /** Get just the floating point number value of the computed line-height; */
          const computedLineHeightNum = parseFloat(computedStyle.getPropertyValue("line-height"));
          /** If the computed line-height is a number (i.e. is not NaN), then ... */
          if (!isNaN(computedLineHeightNum)) {
            /** Calculate the relative em value for the correct font-size to be applied to svg; */
            const autoFontSize = `${computedLineHeightNum /
              computedFontSizeNum}em`;
            /** Set font size accordingly. */
            el.style.fontSize = autoFontSize;
          }
        }
      }
    };
    this.setSize = (el) => {
      if (!sizes[this.size]) {
        /** Try setting the font size automatically. */
        this.trySettingAutoFontSize(el);
      }
      else {
        const classes = Array.from(el.classList);
        const sizeValues = Object.values(sizes);
        classes
          .filter(className => sizeValues.includes(className))
          .forEach(className => el.classList.remove(className));
        el.classList.add(sizes[this.size]);
      }
    };
  }
  render() {
    /** Get correct class based on provided size prop or state-derived value. */
    const classes = {
      "kds-Icon": true,
      /** Apply inline class if size prop is unset or invalid value. */
      "kds-Icon--inline": typeof this.size === "undefined" || !sizes[this.size],
      [colors[this.color]]: Boolean(colors[this.color]),
      [this.hostEl.className]: Boolean(this.hostEl.className)
    };
    return (h("svg", { class: classes, focusable: "false", fill: "currentColor", ref: (el) => this.setSize(el), width: "1em", height: "1em", viewBox: "0 0 16 16" }, this.paths));
  }
  static get is() { return "kds-icon"; }
  static get originalStyleUrls() { return {
    "$": ["../../../node_modules/kds-web-e-commerce-theme/blueprints/Icon/Icon.css"]
  }; }
  static get styleUrls() { return {
    "$": ["../../../node_modules/kds-web-e-commerce-theme/blueprints/Icon/Icon.css"]
  }; }
  static get properties() { return {
    "paths": {
      "type": "unknown",
      "mutable": false,
      "complexType": {
        "original": "JsxElement",
        "resolved": "JsxElement",
        "references": {
          "JsxElement": {
            "location": "import",
            "path": "typescript"
          }
        }
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [{
            "text": "render prop used for generated icons.",
            "name": "Private"
          }],
        "text": ""
      }
    },
    "size": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "\"xs\" | \"s\" | \"m\" | \"l\" | \"xl\"",
        "resolved": "\"l\" | \"m\" | \"s\" | \"xl\" | \"xs\"",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "KDS designated sizes."
      },
      "attribute": "size",
      "reflect": false
    },
    "color": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "| \"subdued\"\n    | \"supportive\"\n    | \"inverse\"\n    | \"interactive\"\n    | \"destructive\"\n    | \"favorable\"\n    | \"destructive-inverse\"\n    | \"favorable-inverse\"\n    | \"neutral-inverse\"\n    | \"callout-inverse\"",
        "resolved": "\"callout-inverse\" | \"destructive\" | \"destructive-inverse\" | \"favorable\" | \"favorable-inverse\" | \"interactive\" | \"inverse\" | \"neutral-inverse\" | \"subdued\" | \"supportive\"",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "KDS designated colors."
      },
      "attribute": "color",
      "reflect": false
    }
  }; }
  static get elementRef() { return "hostEl"; }
}
