import { setNativeAttribute, innerPattern, defaultHostAttributes, innerPrefix } from "./attributes/attributeUtils";
export const registerSlotObserver = (component, callback) => {
  return new MutationObserver(callback.bind(component));
};
export const registerAttributeObserver = component => {
  const { hostEl } = component;
  return new MutationObserver(mutations => {
    // Create a new object from current native attributes
    const newAttrs = Object.assign({}, component.innerAttrs);
    mutations.forEach(({ attributeName }) => {
      const unprefixedName = attributeName.replace(new RegExp(`^${innerPrefix}`), "");
      const value = hostEl.getAttribute(attributeName);
      if (hostEl.hasAttribute(attributeName) &&
        innerPattern.test(attributeName)) {
        // Properly assign the attribute to newAttrs object.
        setNativeAttribute(unprefixedName, value, newAttrs);
      }
      else if (defaultHostAttributes[attributeName] &&
        value !== defaultHostAttributes[attributeName]) {
        console.warn(`Attempted to set "${attributeName}". Use "inner-${attributeName}" instead`);
        hostEl.setAttribute(attributeName, defaultHostAttributes[attributeName]);
      }
      else if (newAttrs[unprefixedName]) {
        delete newAttrs[unprefixedName];
      }
    });
    /** Check if attribute objects are equal before assigning innerAttrs state object,
        trigging a re-render */
    if (!isEquivalent(component.innerAttrs, newAttrs)) {
      component.innerAttrs = Object.assign({}, newAttrs);
    }
  });
};
function isEquivalent(a, b) {
  // Create arrays of property names
  var aProps = Object.getOwnPropertyNames(a);
  var bProps = Object.getOwnPropertyNames(b);
  // If number of properties is different,
  // objects are not equivalent
  if (aProps.length != bProps.length) {
    return false;
  }
  for (var i = 0; i < aProps.length; i++) {
    var propName = aProps[i];
    // If values of same property are not equal,
    // objects are not equivalent
    if (a[propName] !== b[propName]) {
      return false;
    }
  }
  // If we made it this far, objects
  // are considered equivalent
  return true;
}
