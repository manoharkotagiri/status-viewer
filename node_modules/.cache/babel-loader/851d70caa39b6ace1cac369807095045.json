{"ast":null,"code":"/* eslint-disable */\n\n/***********************************************************************************************\n  THIS IS AN AUTO-GENERATED FILE. DO NOT MAKE CHANGES HERE\n\n  Generated on: Fri Nov 13 2020 21:58:49 GMT+0000 (Coordinated Universal Time)\n************************************************************************************************/\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar objectUtils = require('../../../utils/objectUtils.js');\n\nvar stringUtils = require('../../../utils/stringUtils.js');\n\nvar _toConsumableArray = _interopDefault(require('@babel/runtime/helpers/toConsumableArray'));\n\nvar REQUIRED = 'required';\nvar PATTERN = 'pattern';\nvar MIN_LENGTH = 'minLength';\nvar MAX_LENGTH = 'maxLength';\nvar MIN = 'min';\nvar MAX = 'max';\n/**\n * Specify a field to be required\n * @param text Message to show if field is not filled\n * @returns Validation\n */\n\nvar required = function required() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return {\n    _id: REQUIRED,\n    text: stringUtils.isValidNonEmptyString(text) ? text : 'Input is required.',\n    validate: objectUtils.isTruthyOrZero\n  };\n};\n\nrequired._id = REQUIRED;\n/**\n * Specify a field to match a pattern\n * @param regex Regex to test test the field value against\n * @param text Message to show if field does not match the pattern\n * @returns Validation\n */\n\nvar pattern = function pattern() {\n  var regex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /.*/;\n  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return {\n    _id: PATTERN,\n    text: stringUtils.isValidNonEmptyString(text) ? text : 'Input must be valid.',\n    validate: function validate(val) {\n      return regex.test(val);\n    }\n  };\n};\n\npattern._id = PATTERN;\n/**\n * Specify that a field's value must be a minimum allowed length\n * @param length The minimum length\n * @param text Message to show if field does not meet the length requirement\n * @returns Validation\n */\n\nvar minLength = function minLength(length) {\n  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return {\n    _id: MIN_LENGTH,\n    text: stringUtils.isValidNonEmptyString(text) ? text : \"Input must be \".concat(length, \" characters or more.\"),\n    validate: function validate(val) {\n      return Boolean(val) && typeof val === 'string' && val.length >= length;\n    }\n  };\n};\n\nminLength._id = MIN_LENGTH;\n/**\n * Specify that a field's value has a maximum allowed length\n * @param length The minimum length\n * @param text Message to show if field does not meet the length requirement\n * @returns Validation\n */\n\nvar maxLength = function maxLength(length) {\n  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return {\n    _id: MAX_LENGTH,\n    text: stringUtils.isValidNonEmptyString(text) ? text : \"Input must be \".concat(length, \" characters or less.\"),\n    validate: function validate(val) {\n      return Boolean(val) && typeof val === 'string' && val.length <= length;\n    }\n  };\n};\n\nmaxLength._id = MAX_LENGTH;\n/**\n * Specify that a field's number value has a minimum allowed value\n * @param num The minimum value\n * @param text Message to show if field does not meet the value requirement\n * @returns Validation\n */\n\nvar min = function min(num) {\n  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return {\n    _id: MIN,\n    text: stringUtils.isValidNonEmptyString(text) ? text : \"Input must be \".concat(num, \" or more.\"),\n    validate: function validate(val) {\n      return Number(val) >= num;\n    }\n  };\n};\n\nmin._id = MIN;\n/**\n * Specify that a field's number value has a maximum allowed value\n * @param num The maximum value\n * @param text Message to show if field does not meet the value requirement\n * @returns Validation\n */\n\nvar max = function max(num) {\n  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return {\n    _id: MAX,\n    text: stringUtils.isValidNonEmptyString(text) ? text : \"Input must be \".concat(num, \" or less.\"),\n    validate: function validate(val) {\n      return Number(val) <= num;\n    }\n  };\n};\n\nmax._id = MAX;\n\nvar contains = function contains(validations, validation) {\n  return Boolean(validations.find(function (v) {\n    return v._id === validation._id;\n  }));\n};\n\nvar addRequiredToValidations = function addRequiredToValidations() {\n  var validations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var requiredMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ''; // If 'required' prop is present, we want to add it to `validations` prop (if it doesn't have it already) instead of spreading it with props. This is because 'required` is a native HTML attribute and leads to native validation behavior, which is inconsistent with our validation messaging.\n\n  return !contains(validations, required) ? [required(requiredMessage)].concat(_toConsumableArray(validations)) : validations;\n};\n\nexports.addRequiredToValidations = addRequiredToValidations;\nexports.contains = contains;\nexports.max = max;\nexports.maxLength = maxLength;\nexports.min = min;\nexports.minLength = minLength;\nexports.pattern = pattern;\nexports.required = required;","map":{"version":3,"sources":["kds-react/src/components/Form/validations/_prebuiltValidations.js"],"names":["REQUIRED","PATTERN","MIN_LENGTH","MAX_LENGTH","MIN","MAX","required","text","_id","isValidNonEmptyString","validate","isTruthyOrZero","pattern","regex","minLength","Boolean","val","maxLength","min","Number","max","contains","v","validation","addRequiredToValidations","validations","requiredMessage"],"mappings":"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","sourcesContent":["import { isTruthyOrZero } from '../../../utils/objectUtils'\nimport { isValidNonEmptyString } from '../../../utils/stringUtils'\n\nconst REQUIRED = 'required'\nconst PATTERN = 'pattern'\nconst MIN_LENGTH = 'minLength'\nconst MAX_LENGTH = 'maxLength'\nconst MIN = 'min'\nconst MAX = 'max'\n\n/**\n * Specify a field to be required\n * @param text Message to show if field is not filled\n * @returns Validation\n */\nexport const required = (text = '') => ({\n  _id: REQUIRED,\n  text: isValidNonEmptyString(text) ? text : 'Input is required.',\n  validate: isTruthyOrZero\n})\nrequired._id = REQUIRED\n\n/**\n * Specify a field to match a pattern\n * @param regex Regex to test test the field value against\n * @param text Message to show if field does not match the pattern\n * @returns Validation\n */\nexport const pattern = (regex = /.*/, text = '') => ({\n  _id: PATTERN,\n  text: isValidNonEmptyString(text) ? text : 'Input must be valid.',\n  validate: val => regex.test(val)\n})\npattern._id = PATTERN\n\n/**\n * Specify that a field's value must be a minimum allowed length\n * @param length The minimum length\n * @param text Message to show if field does not meet the length requirement\n * @returns Validation\n */\nexport const minLength = (length, text = '') => ({\n  _id: MIN_LENGTH,\n  text: isValidNonEmptyString(text)\n    ? text\n    : `Input must be ${length} characters or more.`,\n  validate: val =>\n    Boolean(val) && typeof val === 'string' && val.length >= length\n})\nminLength._id = MIN_LENGTH\n\n/**\n * Specify that a field's value has a maximum allowed length\n * @param length The minimum length\n * @param text Message to show if field does not meet the length requirement\n * @returns Validation\n */\nexport const maxLength = (length, text = '') => ({\n  _id: MAX_LENGTH,\n  text: isValidNonEmptyString(text)\n    ? text\n    : `Input must be ${length} characters or less.`,\n  validate: val =>\n    Boolean(val) && typeof val === 'string' && val.length <= length\n})\nmaxLength._id = MAX_LENGTH\n\n/**\n * Specify that a field's number value has a minimum allowed value\n * @param num The minimum value\n * @param text Message to show if field does not meet the value requirement\n * @returns Validation\n */\nexport const min = (num, text = '') => ({\n  _id: MIN,\n  text: isValidNonEmptyString(text) ? text : `Input must be ${num} or more.`,\n  validate: val => Number(val) >= num\n})\nmin._id = MIN\n\n/**\n * Specify that a field's number value has a maximum allowed value\n * @param num The maximum value\n * @param text Message to show if field does not meet the value requirement\n * @returns Validation\n */\nexport const max = (num, text = '') => ({\n  _id: MAX,\n  text: isValidNonEmptyString(text) ? text : `Input must be ${num} or less.`,\n  validate: val => Number(val) <= num\n})\nmax._id = MAX\n\nexport const contains = (validations, validation) =>\n  Boolean(validations.find(v => v._id === validation._id))\n\nexport const addRequiredToValidations = (\n  validations = [],\n  requiredMessage = ''\n) => {\n  // If 'required' prop is present, we want to add it to `validations` prop (if it doesn't have it already) instead of spreading it with props. This is because 'required` is a native HTML attribute and leads to native validation behavior, which is inconsistent with our validation messaging.\n\n  return !contains(validations, required)\n    ? [required(requiredMessage), ...validations]\n    : validations\n}\n"]},"metadata":{},"sourceType":"script"}