import { Component, Element, Prop, h, Host, State, Watch } from "@stencil/core";
import { toTitleCase } from "../../utils/stringUtils";
import { generateUniqueString } from "../../utils/generateUniqueString";
import { checkIE } from "../../utils/checkIE";
/**
 * A component used to attach a tooltip to an element.
 * Tooltips allow users to get contextual help or information about specific components when hovering or focusing them.
 */
export class Tooltippable {
    constructor() {
        /** Sets the side a tooltip will appear relative to it's attached element. */
        this.side = "bottom";
        /** Sets how the tooltip will align with it's attached element. */
        this.align = "center";
        this.currentSide = this.side;
        this.currentAlign = this.align;
        this.hideTooltip = false;
        this.intersectionCount = 0;
        this.tooltipId = generateUniqueString();
        this.handleIntersect = entries => {
            entries.forEach(entry => {
                this.intersectionCount++;
                if (this.intersectionCount <= 2) {
                    const clientRect = entry.boundingClientRect;
                    const intersectionRect = entry.intersectionRect;
                    if (this.side === "top" || this.side === "bottom") {
                        if (clientRect.top < intersectionRect.top &&
                            clientRect.top < clientRect.bottom) {
                            this.currentSide = "bottom";
                        }
                        else if (clientRect.bottom > intersectionRect.bottom &&
                            clientRect.bottom > clientRect.top) {
                            this.currentSide = "top";
                        }
                        else if (clientRect.left < intersectionRect.left) {
                            this.currentAlign = "left";
                        }
                        else if (clientRect.right > intersectionRect.right) {
                            this.currentAlign = "right";
                        }
                    }
                    else if (this.side === "left" || this.side === "right") {
                        if (clientRect.left < intersectionRect.left) {
                            this.currentSide = "right";
                        }
                        else if (clientRect.right > intersectionRect.right) {
                            this.currentSide = "left";
                        }
                    }
                }
            });
        };
        this.observer = new IntersectionObserver(this.handleIntersect, {
            root: null,
            rootMargin: "0px",
            threshold: [0.05, 0.25, 0.5, 0.75, 1, 0]
        });
    }
    updateSide(newSide) {
        this.currentSide = newSide;
    }
    updateAlign(newAlign) {
        this.currentAlign = newAlign;
    }
    shouldAlignCenter() {
        if (this.currentAlign === "center") {
            return true;
        }
        else if (this.currentSide === "left" || this.currentSide === "right") {
            return true;
        }
        else {
            return false;
        }
    }
    registerObserver() {
        this.hideTooltip = false;
        clearTimeout(this.intersectionTimeout);
        this.observer && this.observer.observe(this.tooltipContent);
    }
    disconnectObserver() {
        this.intersectionTimeout = setTimeout(() => {
            this.observer && this.observer.unobserve(this.tooltipContent);
            this.currentSide = this.side;
            this.currentAlign = this.align;
            this.hideTooltip = false;
            this.intersectionCount = 0;
            clearTimeout(this.intersectionTimeout);
        }, 250);
    }
    render() {
        const ariaType = this.tooltipType && this.tooltipType === "label"
            ? "aria-labelledby"
            : "aria-describedby";
        const firstChild = this.hostEl.firstElementChild &&
            this.hostEl.firstElementChild.hasAttribute("slot")
            ? this.hostEl.children[1]
            : this.hostEl.firstElementChild;
        const isKdsComponent = firstChild &&
            window &&
            window.customElements.get(firstChild.nodeName.toLowerCase());
        isKdsComponent
            ? firstChild.setAttribute(`inner-${ariaType}`, `kds-Tooltip-${this.tooltipId}`)
            : firstChild &&
                firstChild.setAttribute(ariaType, `kds-Tooltip-${this.tooltipId}`);
        if (isKdsComponent && checkIE()) {
            firstChild.addEventListener("focusin", () => {
                this.tooltip.classList.add("kds-Tooltip--isVisible");
            });
            firstChild.addEventListener("focusout", () => {
                this.tooltip.classList.remove("kds-Tooltip--isVisible");
            });
        }
        return (h(Host, { class: "kds-Tooltippable", onMouseEnter: () => this.registerObserver(), onMouseLeave: () => this.disconnectObserver(), onFocusin: () => this.registerObserver(), onFocusout: () => this.disconnectObserver(), onKeyDown: ({ key }) => {
                if (key === "Escape") {
                    this.hideTooltip = true;
                }
            } },
            h("slot", null),
            h("div", { class: {
                    "kds-Tooltip": true,
                    [`kds-Tooltip--side${toTitleCase(this.currentSide)}`]: true,
                    "kds-Tooltip--alignCenter": this.currentAlign === "center" ||
                        this.currentSide === "right" ||
                        this.currentSide === "left",
                    "kds-Tooltip--alignLeft": this.currentSide !== "right" &&
                        this.currentSide !== "left" &&
                        this.currentAlign === "left",
                    "kds-Tooltip--alignRight": this.currentSide !== "right" &&
                        this.currentSide !== "left" &&
                        this.currentAlign === "right",
                    "kds-Tooltip--horizontal": this.currentSide === "left" || this.currentSide === "right",
                    "kds-Tooltip--vertical": this.currentSide === "bottom" || this.currentSide === "top"
                }, role: "tooltip", hidden: this.hideTooltip, ref: (el) => (this.tooltip = el) },
                h("div", { class: "kds-Tooltip-arrowWrapper" },
                    h("div", { class: "kds-Tooltip-arrow" })),
                h("div", { class: "kds-Tooltip-content", id: `kds-Tooltip-${this.tooltipId}`, ref: (el) => (this.tooltipContent = el) },
                    h("slot", { name: "tooltipText" }),
                    this.tooltipText))));
    }
    static get is() { return "kds-tooltippable"; }
    static get originalStyleUrls() { return {
        "$": ["./kds-tooltippable.css"]
    }; }
    static get styleUrls() { return {
        "$": ["kds-tooltippable.css"]
    }; }
    static get properties() { return {
        "side": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"top\" | \"bottom\" | \"left\" | \"right\"",
                "resolved": "\"bottom\" | \"left\" | \"right\" | \"top\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Sets the side a tooltip will appear relative to it's attached element."
            },
            "attribute": "side",
            "reflect": false,
            "defaultValue": "\"bottom\""
        },
        "align": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"center\" | \"left\" | \"right\"",
                "resolved": "\"center\" | \"left\" | \"right\"",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Sets how the tooltip will align with it's attached element."
            },
            "attribute": "align",
            "reflect": false,
            "defaultValue": "\"center\""
        },
        "tooltipText": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Sets the text that will render inside the tooltip."
            },
            "attribute": "tooltip-text",
            "reflect": false
        },
        "tooltipType": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "\"label\" | \"description\"",
                "resolved": "\"description\" | \"label\"",
                "references": {}
            },
            "required": true,
            "optional": false,
            "docs": {
                "tags": [],
                "text": "Determines if the tooltip acts as a label or description of the tooltipped element and sets proper aria attributes."
            },
            "attribute": "tooltip-type",
            "reflect": false
        }
    }; }
    static get states() { return {
        "currentSide": {},
        "currentAlign": {},
        "hideTooltip": {}
    }; }
    static get elementRef() { return "hostEl"; }
    static get watchers() { return [{
            "propName": "side",
            "methodName": "updateSide"
        }, {
            "propName": "align",
            "methodName": "updateAlign"
        }]; }
}
