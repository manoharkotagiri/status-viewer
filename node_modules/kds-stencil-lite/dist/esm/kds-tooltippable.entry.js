import { r as registerInstance, h, H as Host, g as getElement } from './index-9f4b7c32.js';

const toTitleCase = str => str &&
    str
        .replace(/([a-z0-9])([a-z0-9]*)/gi, 
    //@ts-ignore
    (m, p1, p2) => `${p1.toUpperCase()}${p2.toLowerCase()}`)
        .replace(/[\s-_]/g, "");

let last = null;
const generateUniqueString = () => {
    const now = Date.now();
    last = now > last ? now : last + 1;
    return last.toString(36);
};

//@ts-ignore
const checkIE = () => 
//@ts-ignore
!!window.MSInputMethodContext && !!document.documentMode;

const kdsTooltippableCss = ".kds-Tooltippable{display:inline-block;position:relative;outline:none}.kds-Tooltippable:hover .kds-Tooltip,.kds-Tooltippable>:focus+.kds-Tooltip,.kds-Tooltippable>:hover+.kds-Tooltip,.kds-Tooltippable>[focus-within]+.kds-Tooltip,:focus+.kds-Tooltip,[focus-within]+.kds-Tooltip{opacity:1;visibility:visible}.kds-Tooltippable:hover .kds-Tooltip,.kds-Tooltippable>:focus+.kds-Tooltip,.kds-Tooltippable>[focus-within]+.kds-Tooltip,.kds-Tooltippable>:hover+.kds-Tooltip,:focus+.kds-Tooltip,[focus-within]+.kds-Tooltip{opacity:1;visibility:visible}.kds-Tooltippable:hover .kds-Tooltip,.kds-Tooltippable>:focus+.kds-Tooltip,.kds-Tooltippable>:focus-within+.kds-Tooltip,.kds-Tooltippable>:hover+.kds-Tooltip,:focus+.kds-Tooltip,:focus-within+.kds-Tooltip{opacity:1;visibility:visible}.kds-Tooltip{visibility:hidden;opacity:0;position:absolute;width:12.5rem;z-index:2;-webkit-transition:opacity .15s ease-in,visibility .15s ease-in;transition:opacity .15s ease-in,visibility .15s ease-in}.kds-Tooltip--alignRight{right:0;text-align:right}.kds-Tooltip--alignLeft{left:0;text-align:left}.kds-Tooltip--sideBottom.kds-Tooltip--alignCenter,.kds-Tooltip--sideTop.kds-Tooltip--alignCenter{left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%);text-align:center}.kds-Tooltip--sideLeft.kds-Tooltip--alignCenter,.kds-Tooltip--sideRight.kds-Tooltip--alignCenter{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.kds-Tooltip--sideTop{bottom:calc(100% + .75rem)}.kds-Tooltip--sideRight{left:calc(100% + .75rem);text-align:left}.kds-Tooltip--sideBottom{top:calc(100% + .75rem)}.kds-Tooltip--sideLeft{right:calc(100% + .75rem);text-align:right}.kds-Tooltip-arrowWrapper{position:absolute}.kds-Tooltip--sideBottom>.kds-Tooltip-arrowWrapper,.kds-Tooltip--sideTop>.kds-Tooltip-arrowWrapper{width:100%;height:.75rem}.kds-Tooltip--sideLeft>.kds-Tooltip-arrowWrapper,.kds-Tooltip--sideRight>.kds-Tooltip-arrowWrapper{width:.75rem;height:100%}.kds-Tooltip--sideTop>.kds-Tooltip-arrowWrapper{bottom:-.75rem}.kds-Tooltip--sideRight>.kds-Tooltip-arrowWrapper{left:-.75rem}.kds-Tooltip--sideBottom>.kds-Tooltip-arrowWrapper{top:-.75rem}.kds-Tooltip--sideLeft>.kds-Tooltip-arrowWrapper{right:-.75rem}.kds-Tooltip-arrow{position:absolute;margin:auto;width:0;height:0;border:.5rem solid transparent;color:#1d1e1f}.kds-Tooltip--sideTop .kds-Tooltip-arrow{border-bottom:0;border-top-color:currentColor}.kds-Tooltip--sideRight .kds-Tooltip-arrow{border-left:0;border-right-color:currentColor}.kds-Tooltip--sideBottom .kds-Tooltip-arrow{border-top:0;border-bottom-color:currentColor}.kds-Tooltip--sideLeft .kds-Tooltip-arrow{border-right:0;border-left-color:currentColor}.kds-Tooltip--alignLeft .kds-Tooltip-arrow{left:1rem}.kds-Tooltip--alignRight .kds-Tooltip-arrow{right:1rem}.kds-Tooltip--alignCenter .kds-Tooltip-arrow{top:0;right:0;bottom:0;left:0}.kds-Tooltip--sideBottom.kds-Tooltip--alignCenter .kds-Tooltip-arrow{top:auto}.kds-Tooltip--sideBottom.kds-Tooltip--alignLeft .kds-Tooltip-arrow,.kds-Tooltip--sideBottom.kds-Tooltip--alignRight .kds-Tooltip-arrow{top:auto;bottom:0}.kds-Tooltip--sideTop.kds-Tooltip--alignCenter .kds-Tooltip-arrow{bottom:auto}.kds-Tooltip--sideTop.kds-Tooltip--alignLeft .kds-Tooltip-arrow,.kds-Tooltip--sideTop.kds-Tooltip--alignRight .kds-Tooltip-arrow{top:0;bottom:auto}.kds-Tooltip--sideRight .kds-Tooltip-arrow{left:auto}.kds-Tooltip--sideLeft .kds-Tooltip-arrow{right:auto}.kds-Tooltip-content{padding:.5rem .75rem;line-height:1.481481481481481;color:#fff;font-size:.844rem;text-align:left;text-align:initial;border-radius:.25rem;background:#1d1e1f;display:inline-block;min-width:3.5rem}.kds-Tooltip--isVisible,:focus+.kds-Tooltip--hasFocus,[focus-within]+.kds-Tooltip{opacity:1;visibility:visible}.kds-Tooltip--isVisible,:focus+.kds-Tooltip--hasFocus,:focus-within+.kds-Tooltip{opacity:1;visibility:visible}kds-tooltippable .kds-Tooltip{-webkit-transition:opacity .15s ease-in .1s,visibility .15s ease-in .1s;transition:opacity .15s ease-in .1s,visibility .15s ease-in .1s}";

const Tooltippable = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        /** Sets the side a tooltip will appear relative to it's attached element. */
        this.side = "bottom";
        /** Sets how the tooltip will align with it's attached element. */
        this.align = "center";
        this.currentSide = this.side;
        this.currentAlign = this.align;
        this.hideTooltip = false;
        this.intersectionCount = 0;
        this.tooltipId = generateUniqueString();
        this.handleIntersect = entries => {
            entries.forEach(entry => {
                this.intersectionCount++;
                if (this.intersectionCount <= 2) {
                    const clientRect = entry.boundingClientRect;
                    const intersectionRect = entry.intersectionRect;
                    if (this.side === "top" || this.side === "bottom") {
                        if (clientRect.top < intersectionRect.top &&
                            clientRect.top < clientRect.bottom) {
                            this.currentSide = "bottom";
                        }
                        else if (clientRect.bottom > intersectionRect.bottom &&
                            clientRect.bottom > clientRect.top) {
                            this.currentSide = "top";
                        }
                        else if (clientRect.left < intersectionRect.left) {
                            this.currentAlign = "left";
                        }
                        else if (clientRect.right > intersectionRect.right) {
                            this.currentAlign = "right";
                        }
                    }
                    else if (this.side === "left" || this.side === "right") {
                        if (clientRect.left < intersectionRect.left) {
                            this.currentSide = "right";
                        }
                        else if (clientRect.right > intersectionRect.right) {
                            this.currentSide = "left";
                        }
                    }
                }
            });
        };
        this.observer = new IntersectionObserver(this.handleIntersect, {
            root: null,
            rootMargin: "0px",
            threshold: [0.05, 0.25, 0.5, 0.75, 1, 0]
        });
    }
    updateSide(newSide) {
        this.currentSide = newSide;
    }
    updateAlign(newAlign) {
        this.currentAlign = newAlign;
    }
    shouldAlignCenter() {
        if (this.currentAlign === "center") {
            return true;
        }
        else if (this.currentSide === "left" || this.currentSide === "right") {
            return true;
        }
        else {
            return false;
        }
    }
    registerObserver() {
        this.hideTooltip = false;
        clearTimeout(this.intersectionTimeout);
        this.observer && this.observer.observe(this.tooltipContent);
    }
    disconnectObserver() {
        this.intersectionTimeout = setTimeout(() => {
            this.observer && this.observer.unobserve(this.tooltipContent);
            this.currentSide = this.side;
            this.currentAlign = this.align;
            this.hideTooltip = false;
            this.intersectionCount = 0;
            clearTimeout(this.intersectionTimeout);
        }, 250);
    }
    render() {
        const ariaType = this.tooltipType && this.tooltipType === "label"
            ? "aria-labelledby"
            : "aria-describedby";
        const firstChild = this.hostEl.firstElementChild &&
            this.hostEl.firstElementChild.hasAttribute("slot")
            ? this.hostEl.children[1]
            : this.hostEl.firstElementChild;
        const isKdsComponent = firstChild &&
            window &&
            window.customElements.get(firstChild.nodeName.toLowerCase());
        isKdsComponent
            ? firstChild.setAttribute(`inner-${ariaType}`, `kds-Tooltip-${this.tooltipId}`)
            : firstChild &&
                firstChild.setAttribute(ariaType, `kds-Tooltip-${this.tooltipId}`);
        if (isKdsComponent && checkIE()) {
            firstChild.addEventListener("focusin", () => {
                this.tooltip.classList.add("kds-Tooltip--isVisible");
            });
            firstChild.addEventListener("focusout", () => {
                this.tooltip.classList.remove("kds-Tooltip--isVisible");
            });
        }
        return (h(Host, { class: "kds-Tooltippable", onMouseEnter: () => this.registerObserver(), onMouseLeave: () => this.disconnectObserver(), onFocusin: () => this.registerObserver(), onFocusout: () => this.disconnectObserver(), onKeyDown: ({ key }) => {
                if (key === "Escape") {
                    this.hideTooltip = true;
                }
            } }, h("slot", null), h("div", { class: {
                "kds-Tooltip": true,
                [`kds-Tooltip--side${toTitleCase(this.currentSide)}`]: true,
                "kds-Tooltip--alignCenter": this.currentAlign === "center" ||
                    this.currentSide === "right" ||
                    this.currentSide === "left",
                "kds-Tooltip--alignLeft": this.currentSide !== "right" &&
                    this.currentSide !== "left" &&
                    this.currentAlign === "left",
                "kds-Tooltip--alignRight": this.currentSide !== "right" &&
                    this.currentSide !== "left" &&
                    this.currentAlign === "right",
                "kds-Tooltip--horizontal": this.currentSide === "left" || this.currentSide === "right",
                "kds-Tooltip--vertical": this.currentSide === "bottom" || this.currentSide === "top"
            }, role: "tooltip", hidden: this.hideTooltip, ref: (el) => (this.tooltip = el) }, h("div", { class: "kds-Tooltip-arrowWrapper" }, h("div", { class: "kds-Tooltip-arrow" })), h("div", { class: "kds-Tooltip-content", id: `kds-Tooltip-${this.tooltipId}`, ref: (el) => (this.tooltipContent = el) }, h("slot", { name: "tooltipText" }), this.tooltipText))));
    }
    get hostEl() { return getElement(this); }
    static get watchers() { return {
        "side": ["updateSide"],
        "align": ["updateAlign"]
    }; }
};
Tooltippable.style = kdsTooltippableCss;

export { Tooltippable as kds_tooltippable };
