/* eslint-disable */

/***********************************************************************************************
  THIS IS AN AUTO-GENERATED FILE. DO NOT MAKE CHANGES HERE

  Generated on: Wed Dec 09 2020 21:14:13 GMT+0000 (Coordinated Universal Time)
************************************************************************************************/

import _extends from '@babel/runtime/helpers/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import React, { Component } from 'react';
import cx from 'classnames';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';
import _inherits from '@babel/runtime/helpers/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';

function _createSuper(Derived) {
  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

/**
 * TagGroup render a list of one or more Tag components.
 */
var TagGroup =
/*#__PURE__*/
function (_Component) {
  _inherits(TagGroup, _Component);

  var _super = _createSuper(TagGroup);

  function TagGroup(props) {
    var _this;

    _classCallCheck(this, TagGroup);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "removeTag", function (idxToRemove) {
      var state = _this.state.tagState.get(idxToRemove);

      state.isRemoved = true;

      _this.state.tagState.set(idxToRemove, state);

      _this.moveFocus(idxToRemove);
    });

    _defineProperty(_assertThisInitialized(_this), "moveFocus", function (originalIdx) {
      //  looking for possible prev element
      var prevExistingTags = [];
      var nextExistingTags = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _this.state.tagState[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          if (key < originalIdx && !value.isRemoved) {
            prevExistingTags.push(value);
          } else if (key > originalIdx && !value.isRemoved) {
            nextExistingTags.push(value);
          } else {
            continue;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (prevExistingTags.length > 0) {
        prevExistingTags[prevExistingTags.length - 1].ref.current.focus();
        return;
      }

      if (nextExistingTags.length > 0) {
        nextExistingTags[0].ref.current.focus();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "isNonMixedTagsKinds", function () {
      var childrenArr = React.Children.toArray(_this.props.children).filter(function (child) {
        return child.type.displayName && child.type.displayName === 'Tag';
      });

      if (childrenArr.length === 0) {
        return true;
      }

      if (childrenArr[0].props.kind === 'interactive' || childrenArr[0].props.kind === 'action') {
        return childrenArr.every(function (child) {
          return child.type !== 'Tag' || child.type === 'Tag' && (child.props.kind === 'interactive' || child.props.kind === 'action');
        });
      }

      if (childrenArr[0].props.kind !== 'interactive' && childrenArr[0].props.kind !== 'action') {
        return childrenArr.every(function (child) {
          return child.props.kind !== 'interactive' && child.props.kind !== 'action';
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "renderChildren", function () {
      var childrenArr = React.Children.toArray(_this.props.children);
      return childrenArr.map(function (child, index) {
        if (child.type.displayName && child.type.displayName === 'Tag') {
          return React.cloneElement(child, {
            tag: 'li',
            role: 'listitem',
            'data-index': index,
            ref: _this.state.tagState.get(index).ref,
            onRemove: _this.removeTag
          });
        }

        return child;
      });
    });

    _this.state = {
      tagState: new Map()
    };
    _this.props.children && _this.props.children.map(function (child, index) {
      if (child.type.displayName && child.type.displayName === 'Tag') {
        _this.state.tagState.set(index, {
          isRemoved: false,
          //  existing in DOM
          ref: React.createRef()
        });
      }
    });
    return _this;
  }

  _createClass(TagGroup, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          className = _this$props.className,
          children = _this$props.children,
          ariaLabel = _this$props['aria-label'],
          layout = _this$props.layout,
          props = _objectWithoutProperties(_this$props, ["className", "children", "aria-label", "layout"]); // if (!this.isNonMixedTagsKinds() && process.env.NODE_ENV === 'development') {
      //   console.warn('action kind and non-action kind Tag should not be mixed in TagGroup')
      //   return null
      // }


      return React.createElement("section", _extends({
        className: cx('kds-TagGroup', {
          'with-scroll': layout === 'scroll'
        }, className),
        "aria-label": "Tag Group: ".concat(ariaLabel)
      }, props), React.createElement("ul", {
        className: "kds-TagGroup-list"
      }, this.renderChildren()));
    }
  }]);

  return TagGroup;
}(Component);

_defineProperty(TagGroup, "defaultProps", {
  className: '',
  layout: 'wrap'
});

export default TagGroup;
//# sourceMappingURL=TagGroup.js.map
