/* eslint-disable */

/***********************************************************************************************
  THIS IS AN AUTO-GENERATED FILE. DO NOT MAKE CHANGES HERE

  Generated on: Fri Nov 13 2020 21:58:49 GMT+0000 (Coordinated Universal Time)
************************************************************************************************/

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var functionUtils = require('../../utils/functionUtils.js');
var _isFunction = _interopDefault(require('lodash/fp/isFunction'));

var CAROUSEL_GUTTER_WIDTH = 16;
var CAROUSEL_GRADIENT_WIDTH = 32;
var getCarouselWidth = function getCarouselWidth(carousel) {
  var carouselWidth = 0;

  if (carousel && _isFunction(carousel.getBoundingClientRect)) {
    var _carousel$getBounding = carousel.getBoundingClientRect(),
        carouselWidthWithGradients = _carousel$getBounding.width;

    carouselWidth = carouselWidthWithGradients - CAROUSEL_GRADIENT_WIDTH * 2;
  }

  return Math.max(0, carouselWidth);
};
var getFirstTemplateElement = function getFirstTemplateElement(carousel) {
  return carousel && carousel.querySelector('[data-itemindex]').children[0];
};
var getTemplateWidth = function getTemplateWidth(carousel) {
  var templateWidth = 0; // NOTE: This only works if all template components have the same width. we are okay with this for MVP

  var firstTemplateElement = getFirstTemplateElement(carousel);

  if (firstTemplateElement && _isFunction(firstTemplateElement.getBoundingClientRect)) {

    var _firstTemplateElement = firstTemplateElement.getBoundingClientRect();

    templateWidth = _firstTemplateElement.width;
  }

  return templateWidth;
};
var getNumberOfItemsShown = function getNumberOfItemsShown(carouselWidth, templateWithGutterWidth) {
  return Math.max(Math.floor( // we add CAROUSEL_GUTTER_WIDTH here because we want to handle the scenario where the last
  // item is completely in view but the margin after it is not
  (carouselWidth + CAROUSEL_GUTTER_WIDTH) / templateWithGutterWidth), 1);
}; // we also want it to not break completely if the template elements are wider than the carousel

var getFullContainerWidth = function getFullContainerWidth(templateWithGutterWidth, totalNumberOfItems) {
  return templateWithGutterWidth * totalNumberOfItems - CAROUSEL_GUTTER_WIDTH;
};
/* this is: (the width of all template elements + marginRight on each of them) -
(gutter width/margin since the last element has no marginRight) */

var getStartIndexToRender = function getStartIndexToRender(firstFullyVisibleElementIndex, numberOfItemsShown) {
  return Math.max(0, firstFullyVisibleElementIndex - numberOfItemsShown);
};
var getEndIndexToRender = function getEndIndexToRender(totalNumberOfItems, firstFullyVisibleElementIndex, numberOfItemsShown) {
  return Math.min(totalNumberOfItems, firstFullyVisibleElementIndex + numberOfItemsShown * 2 + 1);
};
var getNumberOfSections = function getNumberOfSections(carouselWidth, totalNumberOfItems, numberOfItemsShown) {
  return carouselWidth === 0 ? 0 : Math.ceil(totalNumberOfItems / numberOfItemsShown);
};
var getCurrentSection = function getCurrentSection(firstFullyVisibleElementIndex, numberOfItemsShown, numberOfSections, isAtEndOfCarousel, totalNumberOfItems) {
  return isAtEndOfCarousel || firstFullyVisibleElementIndex + numberOfItemsShown >= totalNumberOfItems ? numberOfSections : Math.min(Math.floor(firstFullyVisibleElementIndex / numberOfItemsShown) + 1, numberOfSections);
};
var getCarouselScrollPosition = function getCarouselScrollPosition(carousel) {
  return carousel && carousel.scrollLeft || 0;
};
var getIsAtStartOfCarousel = function getIsAtStartOfCarousel(carousel) {
  return getCarouselScrollPosition(carousel) === 0;
};
var getIsAtEndOfCarousel = function getIsAtEndOfCarousel(carousel, containerWidth) {
  var carouselScrollPosition = getCarouselScrollPosition(carousel);
  var carouselWidth = getCarouselWidth(carousel);
  return carouselScrollPosition >= containerWidth - (carouselWidth + 2 * CAROUSEL_GRADIENT_WIDTH);
};
var getFirstFullyVisibleElementIndex = function getFirstFullyVisibleElementIndex(carouselScrollPosition, templateWithGutterWidth) {
  return carouselScrollPosition === 0 ? 0 : Math.ceil((carouselScrollPosition + CAROUSEL_GRADIENT_WIDTH) / templateWithGutterWidth);
};
var scrollCarouselToPosition = function scrollCarouselToPosition(carousel, scrollToPosition) {
  if (!carousel) {
    return;
  }

  if (_isFunction(carousel.scroll)) {
    carousel.scroll(scrollToPosition, 0);
  } else {
    // edge does not support el.scroll(), so we need to fall back to setting scrollLeft for certain browsers
    carousel.scrollLeft = scrollToPosition;
  }
};
var focusCarouselItem = function focusCarouselItem(carousel, indexToFocus) {
  if (!carousel) {
    return;
  }

  var itemToFocus = carousel.querySelector("[aria-posinset=\"".concat(indexToFocus + 1, "\"]"));
  itemToFocus && itemToFocus.focus();
};
var focusCarouselItemAfterScrolling = function focusCarouselItemAfterScrolling(carousel, indexToFocus) {
  if (!carousel) {
    return;
  } // Check that carousel has stopped scrolling first
  // Make sure element supports addEventListener


  var isSupported = carousel.addEventListener;
  if (!isSupported) return; // Create event listener that calls handler after carousel has stopped scrolling

  var scrollListener = functionUtils.debounce(function () {
    focusCarouselItem(carousel, indexToFocus); // Remove event listener

    carousel.removeEventListener('scroll', scrollListener);
  }, 100); // Add event listener

  carousel.addEventListener('scroll', scrollListener);
};
var useCarouselOnScrollCallback = function useCarouselOnScrollCallback(_ref) {
  var carousel = _ref.carousel,
      containerWidth = _ref.containerWidth,
      templateWithGutterWidth = _ref.templateWithGutterWidth,
      firstFullyVisibleElementIndex = _ref.firstFullyVisibleElementIndex,
      setFirstFullyVisibleElementIndex = _ref.setFirstFullyVisibleElementIndex,
      forceUpdate = _ref.forceUpdate,
      previousIsAtEndOfCarousel = _ref.previousIsAtEndOfCarousel;
  return React.useCallback(function () {
    if (!carousel) {
      return;
    }

    var carouselScrollPosition = getCarouselScrollPosition(carousel);
    var newFirstFullyVisibleElementIndex = getFirstFullyVisibleElementIndex(carouselScrollPosition, templateWithGutterWidth);

    if (newFirstFullyVisibleElementIndex !== firstFullyVisibleElementIndex) {
      setFirstFullyVisibleElementIndex(newFirstFullyVisibleElementIndex);
      return;
    }

    if (getIsAtEndOfCarousel(carousel, containerWidth) !== previousIsAtEndOfCarousel) {
      // we need to call this because we aren't guaranteed that firstFullyVisibleElement
      //  will change when we're at the end of the carousel
      forceUpdate();
    }
  }, [carousel, containerWidth, firstFullyVisibleElementIndex, templateWithGutterWidth, setFirstFullyVisibleElementIndex, forceUpdate, previousIsAtEndOfCarousel]);
};
var useCarouselOnPreviousButtonClickCallback = function useCarouselOnPreviousButtonClickCallback(_ref2) {
  var carousel = _ref2.carousel,
      containerWidth = _ref2.containerWidth,
      templateWithGutterWidth = _ref2.templateWithGutterWidth,
      numberOfItemsShown = _ref2.numberOfItemsShown;
  return React.useCallback(function () {
    if (!carousel) {
      return;
    }

    var carouselScrollPosition = getCarouselScrollPosition(carousel);
    var firstFullyVisibleElementIndex = getFirstFullyVisibleElementIndex(carouselScrollPosition, templateWithGutterWidth);
    var numberOfItemsToScroll = numberOfItemsShown;

    if (getIsAtEndOfCarousel(carousel, containerWidth)) {
      // if the number of items in the carousel is not a perfect multiple of the numberOfItemsShown,
      // we want to make sure the pagination dots don't get messed up as the user navigates back
      // through the carousel
      numberOfItemsToScroll = firstFullyVisibleElementIndex % numberOfItemsShown || numberOfItemsShown;
    }

    var indexToScrollTo = firstFullyVisibleElementIndex - numberOfItemsToScroll;
    var scrollToPosition = indexToScrollTo * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH;
    scrollCarouselToPosition(carousel, scrollToPosition);
  }, [carousel, containerWidth, templateWithGutterWidth, numberOfItemsShown]);
};
var useCarouselOnNextButtonClickCallback = function useCarouselOnNextButtonClickCallback(_ref3) {
  var carousel = _ref3.carousel,
      templateWithGutterWidth = _ref3.templateWithGutterWidth,
      templateWidth = _ref3.templateWidth,
      numberOfItemsShown = _ref3.numberOfItemsShown;
  return React.useCallback(function () {
    if (!carousel) {
      return;
    }

    var carouselScrollPosition = getCarouselScrollPosition(carousel);
    var carouselWidth = getCarouselWidth(carousel);
    var firstPartiallyVisibleElementIndex = Math.floor((carouselScrollPosition + CAROUSEL_GRADIENT_WIDTH) / templateWithGutterWidth);
    var indexToScrollTo = firstPartiallyVisibleElementIndex + numberOfItemsShown;
    var scrollToPosition = indexToScrollTo * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH; // this is to account for the scenario where the next index is already in view, but the gutter after it is not

    var isIndexToScrollToAlreadyInView = scrollToPosition - carouselScrollPosition + templateWidth <= carouselWidth;

    if (isIndexToScrollToAlreadyInView) {
      scrollToPosition = (indexToScrollTo + 1) * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH;
    }

    scrollCarouselToPosition(carousel, scrollToPosition);
  }, [carousel, templateWithGutterWidth, templateWidth, numberOfItemsShown]);
};
var useOnSkipToStartButtonClickCallback = function useOnSkipToStartButtonClickCallback(_ref4) {
  var carousel = _ref4.carousel;
  return React.useCallback(function () {
    if (!carousel) {
      return;
    }

    if (getIsAtStartOfCarousel(carousel)) {
      focusCarouselItem(carousel, 0);
      return;
    }

    scrollCarouselToPosition(carousel, 0);
    focusCarouselItemAfterScrolling(carousel, 0);
  }, [carousel]);
};
var useOnSkipToEndButtonClickCallback = function useOnSkipToEndButtonClickCallback(_ref5) {
  var carousel = _ref5.carousel,
      templateWithGutterWidth = _ref5.templateWithGutterWidth,
      totalNumberOfItems = _ref5.totalNumberOfItems,
      containerWidth = _ref5.containerWidth;
  return React.useCallback(function () {
    if (!carousel) {
      return;
    }

    if (getIsAtEndOfCarousel(carousel, containerWidth)) {
      focusCarouselItem(carousel, totalNumberOfItems - 1);
      return;
    }

    var scrollToPosition = totalNumberOfItems * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH;
    scrollCarouselToPosition(carousel, scrollToPosition);
    focusCarouselItemAfterScrolling(carousel, totalNumberOfItems - 1);
  }, [carousel, templateWithGutterWidth, totalNumberOfItems, containerWidth]);
};

exports.CAROUSEL_GRADIENT_WIDTH = CAROUSEL_GRADIENT_WIDTH;
exports.CAROUSEL_GUTTER_WIDTH = CAROUSEL_GUTTER_WIDTH;
exports.focusCarouselItem = focusCarouselItem;
exports.focusCarouselItemAfterScrolling = focusCarouselItemAfterScrolling;
exports.getCarouselScrollPosition = getCarouselScrollPosition;
exports.getCarouselWidth = getCarouselWidth;
exports.getCurrentSection = getCurrentSection;
exports.getEndIndexToRender = getEndIndexToRender;
exports.getFirstFullyVisibleElementIndex = getFirstFullyVisibleElementIndex;
exports.getFirstTemplateElement = getFirstTemplateElement;
exports.getFullContainerWidth = getFullContainerWidth;
exports.getIsAtEndOfCarousel = getIsAtEndOfCarousel;
exports.getIsAtStartOfCarousel = getIsAtStartOfCarousel;
exports.getNumberOfItemsShown = getNumberOfItemsShown;
exports.getNumberOfSections = getNumberOfSections;
exports.getStartIndexToRender = getStartIndexToRender;
exports.getTemplateWidth = getTemplateWidth;
exports.scrollCarouselToPosition = scrollCarouselToPosition;
exports.useCarouselOnNextButtonClickCallback = useCarouselOnNextButtonClickCallback;
exports.useCarouselOnPreviousButtonClickCallback = useCarouselOnPreviousButtonClickCallback;
exports.useCarouselOnScrollCallback = useCarouselOnScrollCallback;
exports.useOnSkipToEndButtonClickCallback = useOnSkipToEndButtonClickCallback;
exports.useOnSkipToStartButtonClickCallback = useOnSkipToStartButtonClickCallback;
//# sourceMappingURL=_carouselFunctions.js.map
