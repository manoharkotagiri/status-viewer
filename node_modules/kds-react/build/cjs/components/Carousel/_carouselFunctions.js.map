{"version":3,"file":"_carouselFunctions.js","sources":["kds-react/src/components/Carousel/_carouselFunctions.js"],"sourcesContent":["import { useCallback } from 'react'\nimport { isFunction } from 'lodash/fp'\nimport { debounce } from '../../utils/functionUtils'\n\nexport const CAROUSEL_GUTTER_WIDTH = 16\nexport const CAROUSEL_GRADIENT_WIDTH = 32\n\nexport const getCarouselWidth = carousel => {\n  let carouselWidth = 0\n  if (carousel && isFunction(carousel.getBoundingClientRect)) {\n    const {\n      width: carouselWidthWithGradients\n    } = carousel.getBoundingClientRect()\n    carouselWidth = carouselWidthWithGradients - CAROUSEL_GRADIENT_WIDTH * 2\n  }\n  return Math.max(0, carouselWidth)\n}\n\nexport const getFirstTemplateElement = carousel =>\n  carousel && carousel.querySelector('[data-itemindex]').children[0]\n\nexport const getTemplateWidth = carousel => {\n  let templateWidth = 0\n  // NOTE: This only works if all template components have the same width. we are okay with this for MVP\n  const firstTemplateElement = getFirstTemplateElement(carousel)\n\n  if (\n    firstTemplateElement &&\n    isFunction(firstTemplateElement.getBoundingClientRect)\n  ) {\n    ;({ width: templateWidth } = firstTemplateElement.getBoundingClientRect())\n  }\n\n  return templateWidth\n}\n\nexport const getNumberOfItemsShown = (carouselWidth, templateWithGutterWidth) =>\n  Math.max(\n    Math.floor(\n      // we add CAROUSEL_GUTTER_WIDTH here because we want to handle the scenario where the last\n      // item is completely in view but the margin after it is not\n      (carouselWidth + CAROUSEL_GUTTER_WIDTH) / templateWithGutterWidth\n    ),\n    1\n  ) // we also want it to not break completely if the template elements are wider than the carousel\n\nexport const getFullContainerWidth = (\n  templateWithGutterWidth,\n  totalNumberOfItems\n) =>\n  templateWithGutterWidth * totalNumberOfItems -\n  CAROUSEL_GUTTER_WIDTH /* this is: (the width of all template elements + marginRight on each of them) -\n  (gutter width/margin since the last element has no marginRight) */\n\nexport const getStartIndexToRender = (\n  firstFullyVisibleElementIndex,\n  numberOfItemsShown\n) => Math.max(0, firstFullyVisibleElementIndex - numberOfItemsShown)\n\nexport const getEndIndexToRender = (\n  totalNumberOfItems,\n  firstFullyVisibleElementIndex,\n  numberOfItemsShown\n) =>\n  Math.min(\n    totalNumberOfItems,\n    firstFullyVisibleElementIndex + numberOfItemsShown * 2 + 1\n  )\n\nexport const getNumberOfSections = (\n  carouselWidth,\n  totalNumberOfItems,\n  numberOfItemsShown\n) =>\n  carouselWidth === 0 ? 0 : Math.ceil(totalNumberOfItems / numberOfItemsShown)\n\nexport const getCurrentSection = (\n  firstFullyVisibleElementIndex,\n  numberOfItemsShown,\n  numberOfSections,\n  isAtEndOfCarousel,\n  totalNumberOfItems\n) =>\n  isAtEndOfCarousel ||\n  firstFullyVisibleElementIndex + numberOfItemsShown >= totalNumberOfItems\n    ? numberOfSections\n    : Math.min(\n      Math.floor(firstFullyVisibleElementIndex / numberOfItemsShown) + 1,\n      numberOfSections\n    )\n\nexport const getCarouselScrollPosition = carousel =>\n  (carousel && carousel.scrollLeft) || 0\n\nexport const getIsAtStartOfCarousel = carousel =>\n  getCarouselScrollPosition(carousel) === 0\n\nexport const getIsAtEndOfCarousel = (carousel, containerWidth) => {\n  const carouselScrollPosition = getCarouselScrollPosition(carousel)\n  const carouselWidth = getCarouselWidth(carousel)\n\n  return (\n    carouselScrollPosition >=\n    containerWidth - (carouselWidth + 2 * CAROUSEL_GRADIENT_WIDTH)\n  )\n}\n\nexport const getFirstFullyVisibleElementIndex = (\n  carouselScrollPosition,\n  templateWithGutterWidth\n) =>\n  carouselScrollPosition === 0\n    ? 0\n    : Math.ceil(\n      (carouselScrollPosition + CAROUSEL_GRADIENT_WIDTH) /\n          templateWithGutterWidth\n    )\n\nexport const scrollCarouselToPosition = (carousel, scrollToPosition) => {\n  if (!carousel) {\n    return\n  }\n\n  if (isFunction(carousel.scroll)) {\n    carousel.scroll(scrollToPosition, 0)\n  } else {\n    // edge does not support el.scroll(), so we need to fall back to setting scrollLeft for certain browsers\n    carousel.scrollLeft = scrollToPosition\n  }\n}\n\nexport const focusCarouselItem = (carousel, indexToFocus) => {\n  if (!carousel) {\n    return\n  }\n\n  const itemToFocus = carousel.querySelector(\n    `[aria-posinset=\"${indexToFocus + 1}\"]`\n  )\n\n  itemToFocus && itemToFocus.focus()\n}\n\nexport const focusCarouselItemAfterScrolling = (carousel, indexToFocus) => {\n  if (!carousel) {\n    return\n  }\n\n  // Check that carousel has stopped scrolling first\n  // Make sure element supports addEventListener\n  const isSupported = carousel.addEventListener\n  if (!isSupported) return\n\n  // Create event listener that calls handler after carousel has stopped scrolling\n  const scrollListener = debounce(() => {\n    focusCarouselItem(carousel, indexToFocus)\n    // Remove event listener\n    carousel.removeEventListener('scroll', scrollListener)\n  }, 100)\n\n  // Add event listener\n  carousel.addEventListener('scroll', scrollListener)\n}\n\nexport const useCarouselOnScrollCallback = ({\n  carousel,\n  containerWidth,\n  templateWithGutterWidth,\n  firstFullyVisibleElementIndex,\n  setFirstFullyVisibleElementIndex,\n  forceUpdate,\n  previousIsAtEndOfCarousel\n}) =>\n  useCallback(() => {\n    if (!carousel) {\n      return\n    }\n\n    const carouselScrollPosition = getCarouselScrollPosition(carousel)\n\n    const newFirstFullyVisibleElementIndex = getFirstFullyVisibleElementIndex(\n      carouselScrollPosition,\n      templateWithGutterWidth\n    )\n\n    if (newFirstFullyVisibleElementIndex !== firstFullyVisibleElementIndex) {\n      setFirstFullyVisibleElementIndex(newFirstFullyVisibleElementIndex)\n      return\n    }\n\n    if (\n      getIsAtEndOfCarousel(carousel, containerWidth) !==\n      previousIsAtEndOfCarousel\n    ) {\n      // we need to call this because we aren't guaranteed that firstFullyVisibleElement\n      //  will change when we're at the end of the carousel\n      forceUpdate()\n    }\n  }, [\n    carousel,\n    containerWidth,\n    firstFullyVisibleElementIndex,\n    templateWithGutterWidth,\n    setFirstFullyVisibleElementIndex,\n    forceUpdate,\n    previousIsAtEndOfCarousel\n  ])\n\nexport const useCarouselOnPreviousButtonClickCallback = ({\n  carousel,\n  containerWidth,\n  templateWithGutterWidth,\n  numberOfItemsShown\n}) =>\n  useCallback(() => {\n    if (!carousel) {\n      return\n    }\n    const carouselScrollPosition = getCarouselScrollPosition(carousel)\n\n    const firstFullyVisibleElementIndex = getFirstFullyVisibleElementIndex(\n      carouselScrollPosition,\n      templateWithGutterWidth\n    )\n\n    let numberOfItemsToScroll = numberOfItemsShown\n\n    if (getIsAtEndOfCarousel(carousel, containerWidth)) {\n      // if the number of items in the carousel is not a perfect multiple of the numberOfItemsShown,\n      // we want to make sure the pagination dots don't get messed up as the user navigates back\n      // through the carousel\n      numberOfItemsToScroll =\n        firstFullyVisibleElementIndex % numberOfItemsShown || numberOfItemsShown\n    }\n\n    const indexToScrollTo =\n      firstFullyVisibleElementIndex - numberOfItemsToScroll\n\n    const scrollToPosition =\n      indexToScrollTo * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH\n\n    scrollCarouselToPosition(carousel, scrollToPosition)\n  }, [carousel, containerWidth, templateWithGutterWidth, numberOfItemsShown])\n\nexport const useCarouselOnNextButtonClickCallback = ({\n  carousel,\n  templateWithGutterWidth,\n  templateWidth,\n  numberOfItemsShown\n}) =>\n  useCallback(() => {\n    if (!carousel) {\n      return\n    }\n\n    const carouselScrollPosition = getCarouselScrollPosition(carousel)\n    const carouselWidth = getCarouselWidth(carousel)\n\n    const firstPartiallyVisibleElementIndex = Math.floor(\n      (carouselScrollPosition + CAROUSEL_GRADIENT_WIDTH) /\n        templateWithGutterWidth\n    )\n\n    const indexToScrollTo =\n      firstPartiallyVisibleElementIndex + numberOfItemsShown\n\n    let scrollToPosition =\n      indexToScrollTo * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH\n\n    // this is to account for the scenario where the next index is already in view, but the gutter after it is not\n    const isIndexToScrollToAlreadyInView =\n      scrollToPosition - carouselScrollPosition + templateWidth <= carouselWidth\n\n    if (isIndexToScrollToAlreadyInView) {\n      scrollToPosition =\n        (indexToScrollTo + 1) * templateWithGutterWidth -\n        CAROUSEL_GRADIENT_WIDTH\n    }\n\n    scrollCarouselToPosition(carousel, scrollToPosition)\n  }, [carousel, templateWithGutterWidth, templateWidth, numberOfItemsShown])\n\nexport const useOnSkipToStartButtonClickCallback = ({ carousel }) =>\n  useCallback(() => {\n    if (!carousel) {\n      return\n    }\n\n    if (getIsAtStartOfCarousel(carousel)) {\n      focusCarouselItem(carousel, 0)\n      return\n    }\n\n    scrollCarouselToPosition(carousel, 0)\n    focusCarouselItemAfterScrolling(carousel, 0)\n  }, [carousel])\n\nexport const useOnSkipToEndButtonClickCallback = ({\n  carousel,\n  templateWithGutterWidth,\n  totalNumberOfItems,\n  containerWidth\n}) =>\n  useCallback(() => {\n    if (!carousel) {\n      return\n    }\n\n    if (getIsAtEndOfCarousel(carousel, containerWidth)) {\n      focusCarouselItem(carousel, totalNumberOfItems - 1)\n      return\n    }\n\n    const scrollToPosition =\n      totalNumberOfItems * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH\n\n    scrollCarouselToPosition(carousel, scrollToPosition)\n    focusCarouselItemAfterScrolling(carousel, totalNumberOfItems - 1)\n  }, [carousel, templateWithGutterWidth, totalNumberOfItems, containerWidth])\n"],"names":["CAROUSEL_GUTTER_WIDTH","CAROUSEL_GRADIENT_WIDTH","getCarouselWidth","carousel","carouselWidth","getBoundingClientRect","carouselWidthWithGradients","width","Math","max","getFirstTemplateElement","querySelector","children","getTemplateWidth","templateWidth","firstTemplateElement","getNumberOfItemsShown","templateWithGutterWidth","floor","getFullContainerWidth","totalNumberOfItems","getStartIndexToRender","firstFullyVisibleElementIndex","numberOfItemsShown","getEndIndexToRender","min","getNumberOfSections","ceil","getCurrentSection","numberOfSections","isAtEndOfCarousel","getCarouselScrollPosition","scrollLeft","getIsAtStartOfCarousel","getIsAtEndOfCarousel","containerWidth","carouselScrollPosition","getFirstFullyVisibleElementIndex","scrollCarouselToPosition","scrollToPosition","scroll","focusCarouselItem","indexToFocus","itemToFocus","focus","focusCarouselItemAfterScrolling","isSupported","addEventListener","scrollListener","debounce","removeEventListener","useCarouselOnScrollCallback","setFirstFullyVisibleElementIndex","forceUpdate","previousIsAtEndOfCarousel","useCallback","newFirstFullyVisibleElementIndex","useCarouselOnPreviousButtonClickCallback","numberOfItemsToScroll","indexToScrollTo","useCarouselOnNextButtonClickCallback","firstPartiallyVisibleElementIndex","isIndexToScrollToAlreadyInView","useOnSkipToStartButtonClickCallback","useOnSkipToEndButtonClickCallback"],"mappings":"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"}