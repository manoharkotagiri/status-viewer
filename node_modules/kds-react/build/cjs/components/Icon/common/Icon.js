/* eslint-disable */

/***********************************************************************************************
  THIS IS AN AUTO-GENERATED FILE. DO NOT MAKE CHANGES HERE

  Generated on: Wed Dec 09 2020 21:14:13 GMT+0000 (Coordinated Universal Time)
************************************************************************************************/

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _objectWithoutProperties = _interopDefault(require('@babel/runtime/helpers/objectWithoutProperties'));
var React = require('react');
var React__default = _interopDefault(React);
var cx = _interopDefault(require('classnames'));
var _classCallCheck = _interopDefault(require('@babel/runtime/helpers/classCallCheck'));
var _createClass = _interopDefault(require('@babel/runtime/helpers/createClass'));
var _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/assertThisInitialized'));
var _inherits = _interopDefault(require('@babel/runtime/helpers/inherits'));
var _possibleConstructorReturn = _interopDefault(require('@babel/runtime/helpers/possibleConstructorReturn'));
var _getPrototypeOf = _interopDefault(require('@babel/runtime/helpers/getPrototypeOf'));
var _defineProperty = _interopDefault(require('@babel/runtime/helpers/defineProperty'));
var _objectSpread = _interopDefault(require('@babel/runtime/helpers/objectSpread2'));
var propOpts = require('./propOpts.js');
var windowUtils = require('../../../utils/windowUtils.js');

function _createSuper(Derived) {
  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}
/**
 * Icons provide visual cues that improve the user's ability to scan the experience. They should be used in moderation to represent simple concepts and actions.
 *
 * Each `Icon` is exported as a named component. e.g. `IconAccount`, `IconAddPlusCard`, etc.
 * This allows you to import only the icons you'll use, which helps to keep bundle size low.
 *
 * By default, icons inherit color. Inline icons are auto-sized to the KDS designated line-height of their supporting text.
 *
 * See: [KDS design documentation for Icons](/design/style/iconographyutility)
 */

var Icon =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Icon, _React$Component);

  var _super = _createSuper(Icon);

  function Icon() {
    var _this;

    _classCallCheck(this, Icon);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      autoFontSize: null,
      autoFontSizeClass: null
    });

    _defineProperty(_assertThisInitialized(_this), "svgRef", React__default.createRef());

    return _this;
  }

  _createClass(Icon, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var size = this.props.size;
      /** Auto font size function which is conditionally called below. */

      var trySettingAutoFontSize = function trySettingAutoFontSize(el) {
        /** If the element is not falsey and the window exists, then ... */
        if (el && windowUtils.getWindow()) {
          /** Get computed styles for element; */
          var computedStyle = windowUtils.getWindow().getComputedStyle(el);
          /** Get just the floating point number value of the computed font-size; */

          var computedFontSizeNum = parseFloat(computedStyle.getPropertyValue('font-size'));
          /** Get the correct class if the font-size is one of KDS designated inline sizes. */

          var autoFontSizeClass = propOpts.inlineSizeMap[computedFontSizeNum.toFixed(1) // .toFixed(1) to match inlineSizeMap keys
          ];
          /** If autoFontSizeClass was retrieved from inlineSizeMap, then ... */

          if (autoFontSizeClass) {
            /** Set state accordingly for immediate use in render. */
            _this2.setState({
              autoFontSizeClass: autoFontSizeClass
            });
          } else {
            /** Otherwise, ... */

            /** Get just the floating point number value of the computed line-height; */
            var computedLineHeightNum = parseFloat(computedStyle.getPropertyValue('line-height'));
            /** If the computed line-height is a number (i.e. is not NaN), then ... */

            if (!isNaN(computedLineHeightNum)) {
              /** Calculate the relative em value for the correct font-size to be applied to svg; */
              var autoFontSize = "".concat(computedLineHeightNum / computedFontSizeNum, "em");
              /** Set state accordingly for immediate use in render. */

              _this2.setState({
                autoFontSize: autoFontSize
              });
            }
          }
        }
      };
      /** If size is not passed or passed size is not one of KDS designated sizes, then ... */


      if (!propOpts.sizes[size]) {
        /** Try setting the font size automatically. */
        trySettingAutoFontSize(this.svgRef.current);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          className = _this$props.className,
          color = _this$props.color,
          size = _this$props.size,
          style = _this$props.style,
          title = _this$props.title,
          children = _this$props.children,
          props = _objectWithoutProperties(_this$props, ["className", "color", "size", "style", "title", "children"]);

      var _this$state = this.state,
          autoFontSizeClass = _this$state.autoFontSizeClass,
          autoFontSize = _this$state.autoFontSize;
      /** Get correct class based on provided size prop or state-derived value. */

      var fontSizeClass = propOpts.sizes[size] || autoFontSizeClass;
      var classes = cx('kds-Icon',
      /** Apply inline class if size prop is unset or invalid value. */
      {
        'kds-Icon--inline': typeof size === 'undefined' || !propOpts.sizes[size]
      }, propOpts.colors[color], fontSizeClass, className);
      return React__default.createElement("svg", _extends({
        className: classes,
        focusable: "false",
        fill: "currentColor",
        ref: this.svgRef,
        width: "1em",
        height: "1em",
        viewBox: "0 0 16 16",
        style:
        /** Set fontSize according to state object if available, spread provided styles on top. */
        _objectSpread({
          fontSize: autoFontSize
        }, style)
      }, props), children, title ? React__default.createElement("title", null, title) : null);
    }
  }]);

  return Icon;
}(React__default.Component);

exports.default = Icon;
//# sourceMappingURL=Icon.js.map
