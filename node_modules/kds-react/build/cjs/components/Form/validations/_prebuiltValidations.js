/* eslint-disable */

/***********************************************************************************************
  THIS IS AN AUTO-GENERATED FILE. DO NOT MAKE CHANGES HERE

  Generated on: Wed Dec 09 2020 21:14:13 GMT+0000 (Coordinated Universal Time)
************************************************************************************************/

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var objectUtils = require('../../../utils/objectUtils.js');
var stringUtils = require('../../../utils/stringUtils.js');
var _toConsumableArray = _interopDefault(require('@babel/runtime/helpers/toConsumableArray'));

var REQUIRED = 'required';
var PATTERN = 'pattern';
var MIN_LENGTH = 'minLength';
var MAX_LENGTH = 'maxLength';
var MIN = 'min';
var MAX = 'max';
/**
 * Specify a field to be required
 * @param text Message to show if field is not filled
 * @returns Validation
 */

var required = function required() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return {
    _id: REQUIRED,
    text: stringUtils.isValidNonEmptyString(text) ? text : 'Input is required.',
    validate: objectUtils.isTruthyOrZero
  };
};
required._id = REQUIRED;
/**
 * Specify a field to match a pattern
 * @param regex Regex to test test the field value against
 * @param text Message to show if field does not match the pattern
 * @returns Validation
 */

var pattern = function pattern() {
  var regex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /.*/;
  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return {
    _id: PATTERN,
    text: stringUtils.isValidNonEmptyString(text) ? text : 'Input must be valid.',
    validate: function validate(val) {
      return regex.test(val);
    }
  };
};
pattern._id = PATTERN;
/**
 * Specify that a field's value must be a minimum allowed length
 * @param length The minimum length
 * @param text Message to show if field does not meet the length requirement
 * @returns Validation
 */

var minLength = function minLength(length) {
  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return {
    _id: MIN_LENGTH,
    text: stringUtils.isValidNonEmptyString(text) ? text : "Input must be ".concat(length, " characters or more."),
    validate: function validate(val) {
      return Boolean(val) && typeof val === 'string' && val.length >= length;
    }
  };
};
minLength._id = MIN_LENGTH;
/**
 * Specify that a field's value has a maximum allowed length
 * @param length The minimum length
 * @param text Message to show if field does not meet the length requirement
 * @returns Validation
 */

var maxLength = function maxLength(length) {
  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return {
    _id: MAX_LENGTH,
    text: stringUtils.isValidNonEmptyString(text) ? text : "Input must be ".concat(length, " characters or less."),
    validate: function validate(val) {
      return Boolean(val) && typeof val === 'string' && val.length <= length;
    }
  };
};
maxLength._id = MAX_LENGTH;
/**
 * Specify that a field's number value has a minimum allowed value
 * @param num The minimum value
 * @param text Message to show if field does not meet the value requirement
 * @returns Validation
 */

var min = function min(num) {
  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return {
    _id: MIN,
    text: stringUtils.isValidNonEmptyString(text) ? text : "Input must be ".concat(num, " or more."),
    validate: function validate(val) {
      return Number(val) >= num;
    }
  };
};
min._id = MIN;
/**
 * Specify that a field's number value has a maximum allowed value
 * @param num The maximum value
 * @param text Message to show if field does not meet the value requirement
 * @returns Validation
 */

var max = function max(num) {
  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return {
    _id: MAX,
    text: stringUtils.isValidNonEmptyString(text) ? text : "Input must be ".concat(num, " or less."),
    validate: function validate(val) {
      return Number(val) <= num;
    }
  };
};
max._id = MAX;
var contains = function contains(validations, validation) {
  return Boolean(validations.find(function (v) {
    return v._id === validation._id;
  }));
};
var addRequiredToValidations = function addRequiredToValidations() {
  var validations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var requiredMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  // If 'required' prop is present, we want to add it to `validations` prop (if it doesn't have it already) instead of spreading it with props. This is because 'required` is a native HTML attribute and leads to native validation behavior, which is inconsistent with our validation messaging.
  return !contains(validations, required) ? [required(requiredMessage)].concat(_toConsumableArray(validations)) : validations;
};

exports.addRequiredToValidations = addRequiredToValidations;
exports.contains = contains;
exports.max = max;
exports.maxLength = maxLength;
exports.min = min;
exports.minLength = minLength;
exports.pattern = pattern;
exports.required = required;
//# sourceMappingURL=_prebuiltValidations.js.map
