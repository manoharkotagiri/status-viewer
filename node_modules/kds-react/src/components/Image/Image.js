import React, { Component } from 'react'
import PropTypes from 'prop-types'
import cx from 'classnames'
import { IconImageMissing, IconGroceries } from '../Icon'

/**
 * **Note:** A height **must** be defined on an `Image`'s parent component in order for the various image states to work correctly.
 */

class Image extends Component {
  constructor (props) {
    super(props)
    this.skeletonRef = React.createRef()
    this.state = {
      isLoading: true,
      isError: false,
      isWaitingLazily: this.props.loading === 'lazy'
    }
    this.handleImageError = this.handleImageError.bind(this)
    this.handleImageLoad = this.handleImageLoad.bind(this)
    this.handleLazyImageInView = this.handleLazyImageInView.bind(this)
  }

  componentDidMount () {
    if (this.props.loading === 'lazy') {
      if (Image.intersectionObserver) {
        Image.DOMElementsToReactElements.set(this.skeletonRef.current, this)
        Image.intersectionObserver.observe(this.skeletonRef.current)
      } else {
        this.handleLazyImageInView()
      }
    }
  }

  static intersectionObserver =
    typeof window !== 'undefined' &&
    !(
      typeof HTMLImageElement !== 'undefined' &&
      'loading' in HTMLImageElement.prototype
    ) &&
    'IntersectionObserver' in window
      ? new IntersectionObserver(
        (entries, observer) => {
          for (const ele of entries) {
            if (ele.isIntersecting) {
              const reactEle = Image.DOMElementsToReactElements.get(
                ele.target
              )
              observer.unobserve(ele.target)
              Image.DOMElementsToReactElements.delete(ele.target)
              reactEle.handleLazyImageInView()
            }
          }
        },
        { rootMargin: '3000px' } // the lazy load threshold from chrome on 4G connections.
      )
      : null

  static DOMElementsToReactElements = new Map()

  static propTypes = {
    /** Pass optional classes to the Image wrapper. */
    className: PropTypes.string,
    /** Define image source on an image. */
    src: PropTypes.string,
    /** Define alt text on an image. */
    alt: PropTypes.string,
    /** Kind of icon to show when image src not provided. */
    icon: PropTypes.elementType,
    /** How the image should be loaded. */
    loading: PropTypes.oneOf(['lazy', 'auto', 'eager'])
  }

  static defaultProps = {
    className: '',
    src: '',
    alt: ''
  }

  // this is a safeguard for accessability - the alt text will always be present regardless of lazy-loaded status
  static _1pxPlaceholderImage =
    'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs='

  handleImageError () {
    this.setState({
      isLoading: false,
      isError: true
    })
  }

  handleImageLoad () {
    this.setState({
      isLoading: false
    })
  }

  handleLazyImageInView () {
    this.setState({
      isWaitingLazily: false
    })
  }

  render () {
    const {
      isSsrd,
      className,
      src,
      alt,
      icon: Icon,
      loading,
      height,
      width,
      ...props
    } = this.props
    const { isLoading, isError, isWaitingLazily } = this.state

    const image = (
      <img
        {...props}
        src={isWaitingLazily ? Image._1pxPlaceholderImage : src}
        alt={alt}
        loading={loading}
        className="kds-Image-img"
        height={!isSsrd && isLoading ? 11 : height}
        width={!isSsrd && isLoading ? 0 : width}
        onError={this.handleImageError}
        onLoad={isWaitingLazily ? undefined : this.handleImageLoad}
      />
    )
    /*
    You probably have questions reading that, I get it. Here are the answers.
    We can't use hidden={isLoading} because Chrome's native lazy-loading won't work on
    most hidden images. display:none doesn't work either. See here:
    https://bugs.chromium.org/p/chromium/issues/detail?id=1016689
    And for why I'm specifically choosing height 11 and width 0 as a workaround, see here:
    https://bugs.chromium.org/p/chromium/issues/detail?id=1025746
    (width in particular is 0 because height gets overridden by CSS)
    */

    /* This is so non-javascript-y robots can still see images from a server-side render. */
    const noscriptImage = (
      <noscript>
        <img {...props} src={src} alt={alt} className="kds-Image-img w-full" />
        <link
          rel="stylesheet"
          href={`data:text/css,${encodeURI(
            '.kds-Image-skeleton{display:none !important}'
          )}`}
        />
      </noscript>
    )

    /** For images without defined `src` props:
     * If no `icon` prop is defined, it defaults to `IconGroceries`
     * */
    const noSrc = this.props.icon ? (
      Icon && <Icon size="xl" color="subdued" />
    ) : (
      <IconGroceries size="xl" color="subdued" />
    )

    /** If an image has a defined src prop but it errors out, a broken image SVG will be returned.
     * If no src has been defined, an icon defined by noSrc will be used. */
    const error = (
      <div
        className="bg-default-200 h-full w-full flex justify-center items-center"
        hidden={!isSsrd && isLoading}
      >
        {src ? <IconImageMissing size="xl" color="subdued" /> : noSrc}
      </div>
    )

    const skeleton = (
      <div
        className="bg-default-200 h-full relative overflow-hidden w-full kds-Image-skeleton"
        data-testid="skeleton"
        ref={loading === 'lazy' && this.skeletonRef}
      />
    )

    const shouldRenderFallback = (isSsrd && !src) || !isSsrd & isError

    return (
      <div
        className={cx(
          'h-full',
          'flex',
          'flex-wrap',
          'flex-col',
          'kds-Image-container',
          'overflow-hidden',
          className
        )}
        aria-busy={!!isLoading}
      >
        {shouldRenderFallback ? error : image}
        {!isSsrd && isLoading && noscriptImage}
        {!isSsrd && isLoading && skeleton}
      </div>
    )
  }
}

export default Image
