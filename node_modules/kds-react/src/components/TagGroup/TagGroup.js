import React, { Component } from 'react'
import cx from 'classnames'
import PropTypes from 'prop-types'

/**
 * TagGroup render a list of one or more Tag components.
 */
class TagGroup extends Component {
  static propTypes = {
    /** One or more `<Tag>` components */
    children: PropTypes.arrayOf(
      PropTypes.shape({
        type: TagGroup
      })
    ),
    /** Optional className to be applied to the container node */
    className: PropTypes.string,
    'aria-label': PropTypes.string,
    layout: PropTypes.oneOf(['wrap', 'scroll'])
  }

  static defaultProps = {
    className: '',
    layout: 'wrap'
  }

  constructor (props) {
    super(props)

    this.state = { tagState: new Map() }

    this.props.children &&
      this.props.children.map((child, index) => {
        if (child.type.displayName && child.type.displayName === 'Tag') {
          this.state.tagState.set(index, {
            isRemoved: false, //  existing in DOM
            ref: React.createRef()
          })
        }
      })
  }

  removeTag = idxToRemove => {
    const state = this.state.tagState.get(idxToRemove)
    state.isRemoved = true
    this.state.tagState.set(idxToRemove, state)
    this.moveFocus(idxToRemove)
  }

  moveFocus = originalIdx => {
    //  looking for possible prev element
    const prevExistingTags = []
    const nextExistingTags = []

    for (const [key, value] of this.state.tagState) {
      if (key < originalIdx && !value.isRemoved) {
        prevExistingTags.push(value)
      } else if (key > originalIdx && !value.isRemoved) {
        nextExistingTags.push(value)
      } else {
        continue
      }
    }

    if (prevExistingTags.length > 0) {
      prevExistingTags[prevExistingTags.length - 1].ref.current.focus()
      return
    }

    if (nextExistingTags.length > 0) {
      nextExistingTags[0].ref.current.focus()
    }
  }

  //  check if action and non-action Tags are mixed, if it's mixed, prevent it.
  isNonMixedTagsKinds = () => {
    const childrenArr = React.Children.toArray(this.props.children).filter(
      child => child.type.displayName && child.type.displayName === 'Tag'
    )

    if (childrenArr.length === 0) {
      return true
    }

    if (
      childrenArr[0].props.kind === 'interactive' ||
      childrenArr[0].props.kind === 'action'
    ) {
      return childrenArr.every(
        child =>
          child.type !== 'Tag' ||
          (child.type === 'Tag' &&
            (child.props.kind === 'interactive' ||
              child.props.kind === 'action'))
      )
    }

    if (
      childrenArr[0].props.kind !== 'interactive' &&
      childrenArr[0].props.kind !== 'action'
    ) {
      return childrenArr.every(
        child =>
          child.props.kind !== 'interactive' && child.props.kind !== 'action'
      )
    }
  }

  renderChildren = () => {
    const childrenArr = React.Children.toArray(this.props.children)

    return childrenArr.map((child, index) => {
      if (child.type.displayName && child.type.displayName === 'Tag') {
        return React.cloneElement(child, {
          tag: 'li',
          role: 'listitem',
          'data-index': index,
          ref: this.state.tagState.get(index).ref,
          onRemove: this.removeTag
        })
      }

      return child
    })
  }

  render () {
    const {
      className,
      children,
      'aria-label': ariaLabel,
      layout,
      ...props
    } = this.props

    // if (!this.isNonMixedTagsKinds() && process.env.NODE_ENV === 'development') {
    //   console.warn('action kind and non-action kind Tag should not be mixed in TagGroup')
    //   return null
    // }

    return (
      <section
        className={cx(
          'kds-TagGroup',
          { 'with-scroll': layout === 'scroll' },
          className
        )}
        aria-label={`Tag Group: ${ariaLabel}`}
        {...props}
      >
        <ul className="kds-TagGroup-list">{this.renderChildren()}</ul>
      </section>
    )
  }
}

export default TagGroup
