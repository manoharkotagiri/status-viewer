import React, { PureComponent } from 'react'
import PropTypes from 'prop-types'
import cx from 'classnames'
import Button from '../Button/Button'
import Text from '../Text/Text'
import { IconMinus, IconPlus, IconTrash } from '../Icon/index'
import { debounce } from '../../utils/functionUtils'
import { clamp } from '../../utils/numberUtils'

function cleanValue (oldValue, newValue, min, max) {
  newValue = parseInt(newValue) || 0
  let value = oldValue
  if (min <= newValue && newValue <= max) {
    value = newValue
  } else if (newValue > max) {
    value = max
  } else if (newValue < min) {
    const direction = newValue - value
    value =
      direction > 0
        ? min // This means we're adding, snap to min
        : 0 // if we're subtracting, snap to zero
  }
  return value
}

const kinds = ['primary', 'secondary']

/**
 * `Stepper` lets users increment and decrement quantities. Use them for things like adding/removing items to/from a cart or list.
 *
 * It handles local state and passes the current value to the `onChange` callback for you to use as needed.
 *
 * Because it wraps the buttons and input in a `div`, additional props will be spread onto the `div`.
 *
 * Stepper comes built in with a 400ms debounce on increment/decrement and input actions.
 *
 * ### Accessibility
 *
 * This component meets the criteria for a `spinbutton` as defined in <a href="https://www.w3.org/TR/wai-aria-1.1/#spinbutton" rel="external">WAI-ARIA 1.1: 5.4 Definition of Roles: spinbutton</a>
 *
 * And it follows patterns informed by <a href="https://www.w3.org/TR/wai-aria-practices-1.1/#spinbutton" rel="external">WAI-ARIA Authoring Practices: Design Patterns and Widgets: Spinbutton</a>
 *
 * >**Note:** IE 11 doesn't natively support keyboard controls for input `type="number"` other than manual numeric entry. Because the KDS defers to native browser behavior for input controls, we do not add this functionality.
 *
 * > ```Message { "props": { "kind": "warning" } }
 * > *THIS COMPONENT IS ON A DEPRECATION PATH.*
 * >
 */

class Stepper extends PureComponent {
  static propTypes = {
    /** Name of the item, ingredient, or whatever thing is being incremented / decremented. Incorporated — along with `callToAction` and/or `description` if provided — into informative output for ARIA attributes. */
    what: PropTypes.string.isRequired,
    /** Pass utility classes to the container element */
    className: PropTypes.string,
    /** Function to execute when input value changes, unless value is out of range (see `max`). Function is debounced by 400ms in most cases; exceptions include calls to the function when — in `callToAction` mode — switching between Stepper and Button. In these cases, the function is called immediately.
     *
     * @param { number } value The updated value of the stepper
     */
    onChange: PropTypes.func,
    /** Renders compact buttons. */
    compact: PropTypes.bool,
    /** Renders a "Call-To-Action" button with the provided text (e.g. `"Add to Cart"`). If provided, the stepper displays a button when the value is 0. Must be title case per KDS Guidelines. */
    callToAction: PropTypes.string,
    /** Renders a small descriptive block below the quantity input field. */
    description: PropTypes.string,
    /** Changes styling of decrement button to "secondary-negative" when value is `<=1`. */
    destructive: PropTypes.bool,
    /** Horizontally centers Stepper and makes "Call-To-Action" button full-width. */
    fullWidth: PropTypes.bool,
    /** Optional maximum number. Must be `>=1` and `<=999`. Out-of-range values will be clamped. */
    max: PropTypes.number,
    /** Defines how many items will be added when the increment button is first clicked. Also determines where the value changes to zero on decrement. */
    minimumQuantity: PropTypes.number,
    /** Sets/Updates the internal value of the stepper when changed. */
    value: PropTypes.number,
    /** Determines the CTA button appearance. */
    kind: PropTypes.oneOf(kinds)
  }

  static defaultProps = {
    callToAction: '',
    compact: false,
    description: '',
    destructive: false,
    fullWidth: false,
    value: 0,
    onChange: () => {},
    max: 999,
    minimumQuantity: 1,
    kind: 'primary'
  }

  state = {
    clampedMax: clamp(this.props.max, 1, 999),
    inputIsFocusedAndZero: false,
    shouldSetFocusOnCTA: false,
    value: this.props.value || 0,
    updatedValue: this.props.value || 0,
    locked: false
  }

  ctaButtonRef = React.createRef()
  lastEmittedValue = this.state.value
  debouncedOnChange = debounce(value => {
    this.props.onChange(value)
    this.lastEmittedValue = value
    this.state.locked = false
  }, 800)
  incrBtnRef = React.createRef()
  getMinimumQuantity = () => Math.max(1, this.props.minimumQuantity)
  isOutOfRange = value => value < 0 || value > this.state.clampedMax
  isLessThanMinQuantity = value =>
    value > 0 && value < this.getMinimumQuantity()
  isInvalid = value =>
    this.isOutOfRange(value) || this.isLessThanMinQuantity(value)
  isEqualToLastEmittedValue = value => value === this.lastEmittedValue
  tryOnChangeCallback = (debounce = true) => {
    /* Get the newly updated value from state. */
    const { value } = this.state

    /* If value is equal to last emitted value, out of range, or otherwise invalid, don't execute callback function. */
    if (!this.isInvalid(value) && !this.isEqualToLastEmittedValue(value)) {
      if (value === 0 || !debounce) {
        /* If the value is 0 we want to fire onChange immediately,
         * so we cancel the debounced version and call it directly. */
        this.state.locked = false
        this.debouncedOnChange.cancel()
        this.props.onChange(value)
        this.lastEmittedValue = value
      } else {
        this.state.locked = true
        this.debouncedOnChange(value)
      }
    }
  }

  cleanValue = newValue => {
    return cleanValue(
      this.state.value,
      newValue,
      this.getMinimumQuantity(),
      this.props.max
    )
  }

  /* Handle updates to updatedValue prop and set value on state */
  static getDerivedStateFromProps (
    { value: propValue },
    { updatedValue, locked }
  ) {
    if (!locked && propValue !== updatedValue) {
      /* In this event we "clean" the value first because a user could have typed anything into the input. */
      const cleanedValue = parseInt(propValue) || 0

      return {
        inputIsFocusedAndZero: cleanedValue !== 0, // indicate when input has focus and zero value
        value: cleanedValue,
        updatedValue: propValue
      }
    } else {
      return { updatedValue: propValue }
    }
  }

  /* We want the "call to action" button to take focus when value is decreased to zero (for accessibility) */
  componentDidUpdate (prevProps) {
    if (this.props.value !== prevProps.value) {
      this.lastEmittedValue = this.props.value
    }

    this.focusOnCTA()
  }

  focusOnCTA = () => {
    const { callToAction } = this.props
    const { inputIsFocusedAndZero, shouldSetFocusOnCTA, value } = this.state

    /* If callToAction prop is set
     * and value is 0
     * and current state indicates that focus should be set on the CTA button
     * and current state indicates that the input is NOT focused with a zero value, ... */
    callToAction &&
      value === 0 &&
      shouldSetFocusOnCTA &&
      !inputIsFocusedAndZero &&
      /* then in the next frame, ... */
      setTimeout(() => {
        /* if the CTA button exists and is focusable, then set focus on it. */
        this.ctaButtonRef &&
          this.ctaButtonRef.current &&
          typeof this.ctaButtonRef.current.focus === 'function' &&
          this.ctaButtonRef.current.focus()

        this.state.shouldSetFocusOnCTA = false
      })
  }

  onCTAButtonClick = () => {
    this.setState({ value: this.getMinimumQuantity() }, () => {
      this.tryOnChangeCallback(this.state.value)

      /* We want the input to take focus when it renders in place of the "call to action" button (for accessibility) */
      this.incrBtnRef.current.focus()
    })
  }

  onDecrementClick = () => {
    this.setState(({ value }) => {
      const cleanedValue = this.cleanValue(value - 1)

      return {
        /** Snap manually entered (typed) invalid value to clamped max. */
        value: cleanedValue,
        inputIsFocusedAndZero: false,
        shouldSetFocusOnCTA: cleanedValue - 1 < this.getMinimumQuantity()
      }
    }, this.tryOnChangeCallback)
  }

  onIncrementClick = () => {
    this.setState(({ value }) => {
      const cleanedValue = this.cleanValue(value + 1)

      return {
        /** Snap manually entered (typed) invalid value to 0. */
        value: cleanedValue
      }
    }, this.tryOnChangeCallback)
  }

  onInputChange = e => {
    /* In this event we "clean" the value first because a user could have typed anything into the input. */
    const cleanedValue = parseInt(e.target.value) || 0

    this.setState({
      inputIsFocusedAndZero: cleanedValue === 0, // indicate when input has focus and zero value
      value: cleanedValue
    })
  }

  onInputKeyPress = e => {
    const { value } = this.state
    /* We want users to have to "commit" a zero typed directly into the focused input. */
    if (e.key === 'Enter') {
      this.setState({
        /* We fake blur by telling state that the input is not focused, so we don't trigger the onInputBlur handler; */
        inputIsFocusedAndZero: false,
        /* In this event, we want to transfer focus back to the CTA button, unlike in a true blur event. */
        shouldSetFocusOnCTA: value === 0
      })
    }
  }

  onInputBlur = () => {
    /* On blur, set state accordingly ... */
    this.setState(
      {
        inputIsFocusedAndZero: false,
        shouldSetFocusOnCTA: false
      },
      () => this.tryOnChangeCallback(false)
    )
  }

  render () {
    const { clampedMax, inputIsFocusedAndZero, value } = this.state
    const {
      className,
      compact,
      callToAction,
      description,
      destructive,
      fullWidth,
      what,
      kind,
      /* The following are destructured to remove from spreadable divProps. */
      children: childrenOmitted, // children not used in this component
      max: maxOmitted, // used in state constructor
      minimumQuantity: minimumQuantityOmitted, // used in various non-render methods
      onChange: onChangeOmitted, // used in various non-render methods
      value: valueOmitted, // used in state constructor and getDerivedStateFromProps,
      /* Remaining props that can be spread onto div as valid attributes; all others have been destructured to omit them. */
      ...divProps
    } = this.props
    const destructiveDecrement =
      destructive && value <= this.getMinimumQuantity()
    const hideCTAButton = value !== 0 || inputIsFocusedAndZero
    const hideStepper = callToAction && !hideCTAButton
    const disableDecrementBtn = value <= 0
    const disableIncrementBtn = value >= clampedMax
    const isInvalid = this.isInvalid(value)
    const invalidMessage = isInvalid
      ? this.isLessThanMinQuantity(value)
        ? `${value} is less than the minimum quantity.`
        : `${value} is more than the maximum quantity.`
      : ''
    let rangeLimitMessage = ''

    /** aria-live message for out-of-range values. */
    if (value <= 0) {
      rangeLimitMessage = 'Minimum Quantity Reached,'
    } else if (value >= clampedMax) {
      rangeLimitMessage = 'Maximum Quantity Reached,'
    }

    return (
      <div {...divProps} className={cx('kds-Stepper', className)}>
        {callToAction && (
          <Button
            aria-label={`${callToAction}: ${what}`}
            className={cx('kds-Stepper-ctaButton', {
              'kds-Stepper-ctaButton--compact': compact,
              'w-full': fullWidth,
              hidden: hideCTAButton
            })}
            compact={compact}
            data-testid="kds-Stepper-ctaButton"
            onClick={this.onCTAButtonClick}
            ref={this.ctaButtonRef}
            kind={kinds.includes(kind) ? kind : undefined}
          >
            {callToAction}
          </Button>
        )}
        <div
          className={cx('kds-Stepper-wrapper', {
            'text-center': fullWidth,
            hidden: hideStepper
          })}
          data-testid="kds-Stepper-wrapper"
        >
          <Button
            aria-label={`Decrement ${what}${
              description ? `, ${description}` : ''
            }`}
            tabIndex={disableDecrementBtn ? -1 : 0}
            compact={compact}
            data-testid="kds-Stepper-decButton"
            disabled={disableDecrementBtn}
            kind={destructiveDecrement ? 'secondary-negative' : 'cancel'}
            onClick={this.onDecrementClick}
          >
            {destructiveDecrement ? <IconTrash /> : <IconMinus />}
          </Button>
          <div
            className={cx('kds-Stepper-inputWrapper', {
              'mx-8': compact
            })}
            data-testid="kds-Stepper-inputWrapper"
          >
            <input
              aria-invalid={isInvalid}
              aria-live="polite"
              aria-label={`${invalidMessage ||
                rangeLimitMessage ||
                'Quantity of'} ${what}${description ? `, ${description}` : ''}`}
              className={cx('kds-Stepper-input', {
                'kds-Stepper-input--descriptive': description
              })}
              data-testid="kds-Stepper-input"
              onBlur={this.onInputBlur}
              onChange={this.onInputChange}
              onKeyPress={this.onInputKeyPress}
              aria-valuemax={clampedMax}
              max={clampedMax}
              aria-valuemin="0"
              min="0"
              type="text"
              inputMode="numeric"
              aria-valuenow={value}
              value={
                /* toString() is necessary to force the browser to strip leading zeros. ¯\_(ツ)_/¯ */
                value.toString()
              }
              style={{
                /* The input is resized to be wide enough for the value with a little wiggle room */
                width: `${value.toString().length * 1.5}ch`
              }}
              tabIndex={
                /* This is required to fix a bug where this button is not perceived as focusable by some versions of VO + Safari. */
                0
              }
            />
            {description && (
              <Text
                aria-hidden="true"
                className="kds-Stepper-description"
                size="s"
              >
                {description}
              </Text>
            )}
          </div>
          <Button
            aria-label={`Increment ${what}${
              description ? `, ${description}` : ''
            }`}
            tabIndex={disableIncrementBtn ? -1 : 0}
            ref={this.incrBtnRef}
            compact={compact}
            data-testid="kds-Stepper-incButton"
            disabled={disableIncrementBtn}
            onClick={this.onIncrementClick}
          >
            <IconPlus />
          </Button>
        </div>
      </div>
    )
  }
}

export default Stepper
