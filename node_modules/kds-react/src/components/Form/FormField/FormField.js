import cx from 'classnames'
import PropTypes from 'prop-types'
import React from 'react'
import {
  getValueFromTarget,
  valOrCamelCasedFallback
} from '../../../utils/formUtils'
import { callAll, callSafely } from '../../../utils/functionUtils'
import { generateUniqueString } from '../../../utils/generationUtils'
import { IconInfo } from '../../Icon/'
import Input from '../../Input/Input'
import Label from '../../Label/Label'
import Link from '../../Link/Link'
import Message from '../../Message/Message'
import MessageGroup from '../../MessageGroup/MessageGroup'
import Paragraph from '../../Paragraph/Paragraph'
import * as prebuiltValidations from '../validations/_prebuiltValidations'

const MoreInfoLink = ({ linkText = 'More Info', content, id }) =>
  content ? (
    <Link
      noRouter
      onClick={() => alert(content)}
      size="m"
      className="ml-8"
      aria-labelledby={id}
    >
      {linkText}
      <IconInfo className="ml-4" />
      <span id={id} className="screen-reader">
        {linkText}, {content}
      </span>
    </Link>
  ) : null

const getKinds = (target, validations, invalidKind) => {
  // Evaluate the value once outside of the map for better perf
  const value = getValueFromTarget(target)

  return validations.map(({ validate }) => {
    const valid = callSafely(validate)(value)

    return valid ? 'success' : invalidKind
  })
}

const _shouldShowMessages = (showMessages, currentState, nextState) => {
  const { focused, validationError } = {
    ...currentState,
    ...nextState
  }

  if (validationError) {
    return true
  }

  if (showMessages === 'onFocus') {
    return focused
  }
}

const ValidationMessages = ({
  id,
  shouldShowMessages,
  validations,
  messageKinds,
  focused,
  invalid,
  shouldShowAdaAlert,
  screenReaderMessages,
  ...props
}) =>
  shouldShowMessages && validations.length > 0 ? (
    <React.Fragment>
      {/*
       * These are the visual messages only, screenreader messaging is below.
       * Note the aria-hidden="true" attr on this MessageGroup
       */}
      <MessageGroup {...props} aria-hidden="true">
        {validations.map(({ text }, index) => {
          const kind = messageKinds[index]

          return (
            <Message key={index} kind={kind}>
              {text}
            </Message>
          )
        })}
      </MessageGroup>
      {/*
       * If we are focused on the input we want to have the messages screenread
       * as an aria-describedby description. So we are rendering a div with an
       * id that will be used within underlying Component's aria-describedby attribute.
       */
        focused && shouldShowMessages && (
          <div id={id} data-testid={id} className="screen-reader">
            {screenReaderMessages}
          </div>
        )}
      {/*
       * If we are NOT focused on the input and it is invalid, we want to have
       * the messages be "alerted" via aria-live="assertive".
       */
        invalid && !focused && shouldShowAdaAlert && (
          <div
            id={`${id}-alert`}
            aria-live="assertive"
            aria-relevant="all"
            aria-atomic="true"
            className="screen-reader"
          >
            {screenReaderMessages}
          </div>
        )}
    </React.Fragment>
  ) : null

/**
 * By default, `FormField` will add an [`Input`](./input) to a [`Form`](./form).
 * You can pass a component through the `as` prop, which will be rendered instead of `Input`, like so:
 * > `<FormField as={MyInputComponent}  {...props} />`.

 *
 * It comes with accessible form features:
 *
 * - label and description
 * - validation messaging
 * - aria attributes
 *
 * All additional props beyond what is specified below will be spread onto the underlying Input (or your custom component), like so:
 * > `<Input {...props} />`.
 *
 * **Requires *custom-event* polyfill for custom validations to work in IE11** [See Polyfills](./polyfills)
 */
class FormField extends React.Component {
  id = `${generateUniqueString()}-input`

  constructor (props) {
    super(props)
    const { required, validations } = props
    const { addRequiredToValidations } = prebuiltValidations
    this._validations = required
      ? addRequiredToValidations(validations)
      : validations

    this.state = {
      messageKinds: this._validations.map(() => 'info'),
      focused: false,
      validationError: false,
      shouldShowMessages: false,
      shouldShowAdaAlert: false
    }

    this.inputRef = props.inputRef || React.createRef()
  }

  componentDidMount () {
    if (this.inputRef && this.inputRef.current) {
      const el = this.inputRef.current
      const oldFn = el.checkValidity.bind(el)
      el.checkValidity = () => {
        const messageKinds = getKinds(el, this._validations, 'error')
        const validationError = messageKinds.some(kind => kind === 'error')
        this.setState({
          messageKinds,
          validationError,
          shouldShowMessages: _shouldShowMessages(
            this.props.showMessages,
            this.state,
            {
              validationError
            }
          )
        })

        return !validationError && oldFn()
      }

      el.restoreDefaultState = () => {
        this.setState({
          messageKinds: this._validations.map(() => 'info'),
          focused: false,
          shouldShowMessages: false,
          shouldShowAdaAlert: false,
          submitError: false
        })
      }
    }
  }

  componentDidUpdate (prevProps, prevState) {
    const shouldSetFocus =
      typeof this.props.focusOn !== 'undefined'
        ? !prevProps.focusOn && this.props.focusOn
        : (!prevProps.serverMessages ||
            prevProps.serverMessages.length === 0) &&
          this.props.serverMessages &&
          this.props.serverMessages.length > 0
    const previousKinds = prevState.messageKinds
    const messageKindsChanged =
      this.state.messageKinds
        .map((currentKind, index) => currentKind === previousKinds[index])
        .filter(same => !same).length > 0

    if (messageKindsChanged) {
      const payload = {
        messagesShown: this.state.shouldShowMessages && this.state.messageKinds
      }
      let validationEvent

      try {
        validationEvent = new CustomEvent('validation', {
          bubbles: true,
          detail: payload
        })
      } catch (e) {
        throw new Error(
          'KDS FormField validations error. You may need the custom-event polyfill http://design.kroger.com/#/react/components/polyfills'
        )
      }

      this.inputRef.current.setAttribute(
        'data-messagesShown',
        JSON.stringify(
          this.state.shouldShowMessages
            ? this.state.messageKinds.map((kind, index) => ({
              messageText: this._validations[index].text,
              messageKind: kind
            }))
            : []
        )
      )
      this.inputRef.current.dispatchEvent(validationEvent)
    }

    if (shouldSetFocus) {
      setTimeout(() => {
        this.inputRef.current.focus()
      }, 0)
    }
  }

  handleFocus = () => {
    const { shouldShowMessages } = this.state
    const nextMeta = { focused: true }

    this.setState({
      ...nextMeta,
      shouldShowMessages:
        shouldShowMessages ||
        _shouldShowMessages(this.props.showMessages, this.state, nextMeta),
      shouldShowAdaAlert: false
    })
  }

  handleChange = event => {
    const { validationError } = this.state
    const messageKinds = getKinds(
      event.target,
      this._validations,
      validationError ? 'error' : 'info'
    )
    const messageKindsChanged =
      this.state.messageKinds
        .map((currentKind, index) => currentKind === messageKinds[index])
        .filter(same => !same).length > 0
    if (messageKindsChanged) {
      this.setState({ messageKinds })
    }
  }

  handleBlur = event => {
    this.setState({
      focused: false
    })
    setTimeout(
      () =>
        this.setState(prevState => ({
          ...prevState,
          shouldShowAdaAlert: true
        })),
      250
    )
  }

  render () {
    let {
      as: Component,
      name,
      label,
      required: requiredProp,
      validations,
      showMessages,
      className,
      moreInfo,
      helpText,
      button,
      inputRef,
      serverMessages = [],
      ...props
    } = this.props

    const {
      messageKinds,
      focused,
      validationError,
      shouldShowMessages,
      shouldShowAdaAlert
    } = this.state

    const required = prebuiltValidations.contains(
      this._validations,
      prebuiltValidations.required
    )

    const serverError = serverMessages.length > 0
    const invalid =
      serverError ||
      (validationError && messageKinds.some(kind => kind === 'error'))
    const metaClasses = cx({
      'is-invalid': invalid,
      'is-focused': focused,
      'is-required': required
    })

    const screenReaderMessages = (!validationError && serverError
      ? serverMessages
      : this._validations
        .filter((_, i) => messageKinds[i] !== 'success')
        .map(({ text }) => text)
    ).join('. ')

    const id = props.id || this.id
    const helpTextId = helpText ? `${id}-helpText` : ''
    const moreInfoId = moreInfo ? `${id}-moreInfo` : ''
    const messagesId = shouldShowMessages || serverError ? `${id}-messages` : ''
    /* Create a space-separated list of ids or an empty string.
    // Order matters for AT users. Please preserve: help text, more info, validation messages */
    const ariaDescribedbyIds = [helpTextId, moreInfoId, messagesId]
      .join(' ')
      .trim()

    const IconButton = button && standardizeIconButton(button, id)

    return (
      <div
        className={cx('kds-Form--field kds-FormField', metaClasses, className)}
      >
        {label && (
          <span className="flex">
            <Label htmlFor={id} className="mb-8">
              {label}
            </Label>
            <MoreInfoLink id={moreInfoId} {...moreInfo} />
          </span>
        )}

        {helpText && (
          <Paragraph id={helpTextId} size="s" className="-mt-4 mb-8">
            {helpText}
          </Paragraph>
        )}

        <div className="kds-FormField-inputWrapper flex items-center">
          <Component
            {...props}
            ref={this.inputRef}
            id={id}
            name={valOrCamelCasedFallback(name, label)}
            aria-describedby={ariaDescribedbyIds || null}
            aria-invalid={invalid}
            aria-required={required}
            onFocus={callAll(this.handleFocus, this.props.onFocus)}
            onChange={callAll(this.handleChange, this.props.onChange)}
            onBlur={callAll(this.handleBlur, this.props.onBlur)}
            className={cx(button && 'kds-FormField-input--withIconButton')}
          />
          {IconButton}
        </div>
        <ValidationMessages
          id={messagesId}
          shouldShowMessages={shouldShowMessages || serverError}
          validations={
            !validationError && serverError
              ? serverMessages.map(text => ({ text }))
              : this._validations
          }
          messageKinds={
            !validationError && serverError
              ? serverMessages.map(() => 'error')
              : messageKinds
          }
          focused={focused}
          invalid={invalid}
          shouldShowAdaAlert={shouldShowAdaAlert}
          screenReaderMessages={screenReaderMessages}
        />
      </div>
    )
  }
}

FormField.propTypes = {
  /** The component to be rendered instead of Input. */
  as: PropTypes.any,
  /** Text for this field's label. Do **not** put a colon at the end of the label. */
  label: PropTypes.string.isRequired,
  /** Name for this field. Will be used as the key in the form data object passed to the `onSubmit` handler. Defaults to the value of the `label` prop. */
  name: PropTypes.string,
  /** If `true`, then this input will be required and show a message that it is required. */
  required: PropTypes.bool,
  /** An array of pre-built [`Form.validations`](./forminput#Validations) and/or [custom validations](./forminput#Custom%20Validations),
   * where `text` is the message to show, and `validate` is a predicate to test for the validation's
   * success state.
   * **Requires *custom-event* polyfill to work in IE11** [See Polyfills](./polyfills) */
  validations: PropTypes.arrayOf(
    PropTypes.shape({
      text: PropTypes.string.isRequired,
      validate: PropTypes.func.isRequired
    })
  ),
  /** An additional event for which you'd like to show the validation messages. All validation messages will also be shown on *Form* submit by default. */
  showMessages: PropTypes.oneOf(['onFocus']),
  /** A list of server error messages to display to the user. **Must** clear on every submit, **Only** provide when server response returns with error */
  serverMessages: PropTypes.arrayOf(PropTypes.string),
  /** Sets focus on this field if there are any server error messages. **Only** provide to one field at a time in the form. */
  focusOn: PropTypes.bool,
  /** Text to accompany the input label for a more detailed description. */
  helpText: PropTypes.string,
  /** Adds a "More Info" link that shows a modal with content for long additional information. */
  moreInfo: PropTypes.shape({
    linkText: PropTypes.string,
    content: PropTypes.string.isRequired
  }),
  /** Adds an Icon Button to the right side of the input.
   * Should always be something like `<Button><Icon /></Button>` */
  button: PropTypes.element,
  /** Reference to the underlying input */
  inputRef: PropTypes.ref
}

FormField.defaultProps = {
  as: Input,
  validations: []
}

function standardizeIconButton (button, inputId) {
  const onlyButton = React.Children.only(button)
  const onlyIcon = React.Children.only(button.props.children)

  return React.cloneElement(onlyButton, {
    ...onlyButton.props,
    kind: 'tertiary',
    type: 'button',
    'aria-controls': inputId,
    className: cx('kds-FormField-iconButton', onlyButton.props.className),
    children: React.cloneElement(onlyIcon, {
      ...onlyIcon.props,
      size: 'm',
      className: cx('kds-FormField-icon', onlyIcon.props.className),
      color: 'interactive'
    })
  })
}

export default FormField
