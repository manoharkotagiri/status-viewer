import React from 'react'
import { render, fireEvent } from 'react-testing-library'
import Form from '../Form'
import FormField from './FormField'
import { IconAccount, IconClose } from '../../Icon'
import Button from '../../Button/Button'
import { renderWithForm } from '../../../utils/formTestUtils'
const { required } = Form.validations

jest.mock('../../../utils/generationUtils', () => ({
  generateUniqueString: () => '1234'
}))

/**
 * Usage: expectInput(inputEl).toBeDescribedBy(descEl)
 */
const expectInput = el => ({
  toBeDescribedBy: descEl =>
    expect(el.getAttribute('aria-describedby').includes(descEl.id)).toBe(true)
})

describe('FormField', () => {
  it('adds custom class to container', () => {
    const { container } = render(
      <FormField label="First Name" className="MyInput" />
    )

    expect(container.firstChild).toHaveClass('MyInput')
  })

  it('uses label as name', () => {
    const { getByLabelText } = render(<FormField label="First Name" />)

    expect(getByLabelText('First Name').name).toBe('firstName')
  })

  it('accepts name prop to set name', () => {
    const { getByLabelText } = render(
      <FormField name="firstName" label="First Name" />
    )

    expect(getByLabelText('First Name').name).toBe('firstName')
  })

  it('spreads additional props to input', () => {
    const { getByLabelText } = render(
      <FormField label="First Name" placeholder="1000" type="number" disabled />
    )

    expect(getByLabelText('First Name')).toBeDisabled()
    expect(getByLabelText('First Name')).toHaveAttribute('placeholder', '1000')
    expect(getByLabelText('First Name')).toHaveAttribute('type', 'number')
  })

  it('does not show validation message onBlur', () => {
    const { getByLabelText, getByText, queryByText } = render(
      <FormField label="First Name" validations={[required()]} />
    )

    fireEvent.focus(getByLabelText('First Name'))

    expect(queryByText('Input is required.')).toBeNull()

    fireEvent.blur(getByLabelText('First Name'))

    expect(queryByText('Input is required.')).toBeNull()
  })

  it('should not have attribute aria-describedby when no help text, more info link, nor validation messages are provided.', () => {
    const { getByLabelText } = render(
      <FormField label="First Name" className="MyInput" />
    )
    const inputEl = getByLabelText('First Name')
    expect(inputEl.getAttribute('aria-describedby')).toBe(null)
  })

  it('shows validation message while focused in showMessages="onFocus" mode', () => {
    const { getByLabelText, getByText, getByTestId } = render(
      <FormField
        label="First Name"
        validations={[required()]}
        showMessages="onFocus"
      />
    )

    const inputEl = getByLabelText('First Name')

    fireEvent.focus(inputEl)

    expect(getByText('Input is required.')).toBeInTheDocument()
    expectInput(inputEl).toBeDescribedBy(getByTestId('1234-input-messages'))
  })

  it('shows help text', () => {
    const { getByText, getByLabelText } = render(
      <FormField label="First Name" helpText="I am help text" />
    )

    const helpTextEl = getByText('I am help text')
    const inputEl = getByLabelText('First Name')

    expect(helpTextEl).toBeInTheDocument()
    expectInput(inputEl).toBeDescribedBy(helpTextEl)
  })

  it('shows more info link', () => {
    global.alert = jest.fn()

    const { getByText, getByLabelText } = render(
      <FormField
        label="First Name"
        moreInfo={{ content: 'I am more info content' }}
      />
    )

    const moreInfoHiddenText = getByText(/I am more info content/)
    const inputEl = getByLabelText('First Name')

    expectInput(inputEl).toBeDescribedBy(moreInfoHiddenText)
    expect(getByText('More Info')).toBeInTheDocument()

    fireEvent.click(getByText('More Info'))

    expect(global.alert).toBeCalledWith('I am more info content')
  })

  it('Renders a Button when button prop is passed', () => {
    const { container } = render(
      <FormField
        button={
          <Button>
            <IconAccount />
          </Button>
        }
      />
    )

    const button = container.querySelector('.kds-FormField-iconButton')

    expect(button).toBeInTheDocument()
    expect(button).toHaveClass('kds-Button--tertiary')
  })

  it('Spreads the expected props into the Button and Icon passed in the button prop', () => {
    const { container } = render(
      <FormField
        button={
          <Button extra-prop="foo" className="extraButtonClass">
            <IconAccount extra-prop="bar" className="extraIconClass" />
          </Button>
        }
      />
    )

    const button = container.querySelector('.kds-FormField-iconButton')
    const icon = button.querySelector('.kds-FormField-icon')

    expect(button).toBeInTheDocument()
    expect(button).toHaveClass('kds-Button--tertiary')
    expect(button).toHaveClass('extraButtonClass')
    expect(button).toHaveAttribute('type', 'button')
    expect(button).toHaveAttribute('aria-controls')
    expect(button).toHaveAttribute('extra-prop', 'foo')

    expect(icon).toBeInTheDocument()
    expect(icon).toHaveClass('kds-Icon--utilityMedium')
    expect(icon).toHaveClass('extraIconClass')
    expect(icon).toHaveClass('kds-Icon--interactive')
    expect(icon).toHaveAttribute('extra-prop', 'bar')
  })

  it('Adds padding to the right of the input when an Icon is added', () => {
    const { container } = render(
      <FormField
        button={
          <Button>
            <IconAccount />
          </Button>
        }
      />
    )

    expect(
      container.querySelector('.kds-FormField-inputWrapper .kds-Input')
    ).toHaveClass('kds-FormField-input--withIconButton')
  })

  it('calls the onClick function when the Icon Button is clicked', () => {
    const mockFn = jest.fn()
    const { container } = render(
      <FormField
        button={
          <Button onClick={mockFn}>
            <IconAccount />
          </Button>
        }
      />
    )

    fireEvent.click(container.querySelector('.kds-FormField-iconButton'))

    expect(mockFn).toBeCalled()
  })

  it('throws an error if more than one child is passed to the button prop', () => {
    const tempLog = console.error
    console.error = jest.fn()

    let threwError = false
    try {
      const { container } = render(
        <FormField
          button={
            <Button>
              <IconAccount />
              <IconAccount />
            </Button>
          }
        />
      )
    } catch (error) {
      threwError = true
    }

    expect(threwError).toBeTruthy()
    expect(console.error).toBeCalled()

    console.error = tempLog
  })

  it('Allows a ref to be passed to the input via the inputRef prop', () => {
    const ref = React.createRef()
    const { container } = render(<FormField inputRef={ref} />)
    const input = container.querySelector('input')
    input.value = 'test value'

    expect(ref.current.value).toBe('test value')
  })

  it('calls validations when checkValidity is called', () => {
    const validateMock = jest.fn()
    const ref = React.createRef()
    render(
      <FormField
        inputRef={ref}
        validations={[{ text: 'mock validation', validate: validateMock }]}
      />
    )

    const validityResult = ref.current.checkValidity()
    expect(validityResult).toBeFalsy()
    expect(validateMock).toBeCalled()
  })

  it('shows validation messages when checkValidity is false', () => {
    const validateMockTrue = jest.fn(() => true)
    const validateMockFalse = jest.fn(() => false)
    const ref = React.createRef()
    const { getByText } = render(
      <FormField
        inputRef={ref}
        validations={[
          { text: 'mock false', validate: validateMockFalse },
          { text: 'mock true', validate: validateMockTrue }
        ]}
      />
    )

    const validityResult = ref.current.checkValidity()
    const trueMessage = getByText('mock true')
    const falseMessage = getByText('mock false')

    expect(validityResult).toBeFalsy()
    expect(trueMessage.parentElement).toHaveClass('kds-Message--success')
    expect(falseMessage.parentElement).toHaveClass('kds-Message--error')
    expect(validateMockTrue).toBeCalled()
    expect(validateMockFalse).toBeCalled()
  })

  it('does not show validation messages when checkValidity is true', () => {
    const validateMockTrue = jest.fn(() => true)
    const ref = React.createRef()
    const { container } = render(
      <FormField
        inputRef={ref}
        validations={[{ text: 'mock true', validate: validateMockTrue }]}
      />
    )

    const validityResult = ref.current.checkValidity()

    expect(validityResult).toBeTruthy()
    expect(container.querySelector('.kds-Message')).not.toBeInTheDocument()
    expect(validateMockTrue).toBeCalled()
  })

  it('dispatches a validation event and sets attribute "data-messagesShown" only when message kinds change', () => {
    const handleValidationMock = jest.fn()
    const ref = React.createRef()
    const { getByLabelText, getForm } = renderWithForm(
      <FormField
        label="Name"
        inputRef={ref}
        validations={[
          {
            text: 'Must be longer than 3 characters',
            validate: value => value.length > 3
          }
        ]}
      />
    )
    const input = getByLabelText('Name')
    input.addEventListener('validation', handleValidationMock)

    expect(input).not.toHaveAttribute('data-messagesShown')

    fireEvent.submit(getForm())
    fireEvent.submit(getForm())
    fireEvent.submit(getForm())

    expect(input).toHaveAttribute(
      'data-messagesShown',
      JSON.stringify([
        {
          messageText: 'Must be longer than 3 characters',
          messageKind: 'error'
        }
      ])
    )

    expect(handleValidationMock).toBeCalledTimes(1)
    expect(handleValidationMock.mock.calls[0][0].target).toBe(input)
    expect(handleValidationMock.mock.calls[0][0].detail.messagesShown).toEqual([
      'error'
    ])

    fireEvent.focus(input)
    fireEvent.change(input, { target: { value: 'ab' } })
    expect(handleValidationMock).toBeCalledTimes(1)
    expect(handleValidationMock.mock.calls[0][0].detail.messagesShown).toEqual([
      'error'
    ])

    fireEvent.change(input, { target: { value: 'abcd' } })
    expect(handleValidationMock).toBeCalledTimes(2)
    expect(handleValidationMock.mock.calls[1][0].detail.messagesShown).toEqual([
      'success'
    ])

    fireEvent.change(input, { target: { value: 'abc' } })
    expect(handleValidationMock).toBeCalledTimes(3)
    expect(handleValidationMock.mock.calls[2][0].detail.messagesShown).toEqual([
      'error'
    ])
  })

  it('clears validation messages when restoreDefaultState method is invoked', done => {
    const ref = React.createRef()
    const mockFn = jest.fn()
    const { baseElement, getByLabelText, queryByText, container } = render(
      <Form>
        <FormField
          label="Name"
          inputRef={ref}
          validations={[
            {
              text: 'Must be longer than 3 characters',
              validate: value => value.length > 3
            }
          ]}
          button={
            <Button
              onClick={() => {
                ref.current.value = ''
                ref.current.restoreDefaultState()
                mockFn()
              }}
            >
              <IconClose />
            </Button>
          }
        />
      </Form>
    )

    const input = getByLabelText('Name')
    const clearBtn = container.querySelector('button')

    fireEvent.change(input, { target: { value: 'ab' } })
    fireEvent.submit(baseElement.querySelector('form'))

    const message = queryByText('Must be longer than 3 characters')

    expect(input.value).toBe('ab')
    expect(message).toBeInTheDocument()

    fireEvent.click(clearBtn)
    expect(mockFn).toBeCalled()

    setTimeout(() => {
      expect(input.value).toBe('')
      expect(message).not.toBeInTheDocument()
      done()
    })
  })

  it('shows error message from server when serverMessages are passed in', () => {
    const { getByLabelText, queryByText, rerender } = renderWithForm(
      <FormField
        label="Name"
        validations={[
          {
            text: 'Must be longer than 3 characters',
            validate: value => value.length > 3
          }
        ]}
      />
    )
    const getMessage = () =>
      queryByText('There was a server error because of this field.')

    expect(getMessage()).not.toBeInTheDocument()

    rerender(
      <FormField
        label="Name"
        validations={[
          {
            text: 'Must be longer than 3 characters',
            validate: value => value.length > 3
          }
        ]}
        serverMessages={['There was a server error because of this field.']}
        focusOn
      />
    )

    expect(getMessage()).toBeInTheDocument()
  })
})
