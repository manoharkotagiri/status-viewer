import React from 'react'
import { render, fireEvent } from 'react-testing-library'
import Button from '../Button/Button'
import Form from './Form'
import FormText from './FormText/FormText'
import FormCheckbox from './FormCheckbox/FormCheckbox'
import FormRadioGroup from './FormRadioGroup/FormRadioGroup'

describe('Form', () => {
  it('renders a form with children and custom class', () => {
    const { container } = render(
      <Form onSubmit={jest.fn()} className="MyForm">
        <input />
        <button />
      </Form>
    )

    expect(container.firstChild).toMatchInlineSnapshot(`
<form
  class="kds-Form MyForm"
  method="POST"
>
  <input />
  <button />
</form>
`)
  })

  it('provides form data to the onSubmit callback. Supports inputs, checkboxes, radios.', () => {
    const onSubmitFn = jest.fn()
    const { getByText } = render(
      <Form onSubmit={onSubmitFn}>
        <FormText label="Text Input" value="bar" />
        <FormCheckbox label="Checkbox 1" />
        <FormCheckbox label="Checkbox 2" checked />
        <FormRadioGroup
          name="radio"
          options={[
            { label: 'Radio One', value: 'one', checked: true },
            { label: 'Radio Two', value: 'two' },
            { label: 'Radio Three', value: 'three' }
          ]}
        />
        <Button>Submit</Button>
      </Form>
    )

    fireEvent.click(getByText('Submit'))

    expect(onSubmitFn.mock.calls[0][0]).toMatchObject({
      textInput: 'bar',
      checkbox1: false,
      checkbox2: true,
      radio: 'one'
    })
  })

  it('provides access to form controls as static properties', () => {
    const staticKeys = Object.keys(Form)

    expect(staticKeys).toContain('validations')
  })

  it('Validates all form elements when submit event is fired', () => {
    const validations = new Array(3)
      .fill()
      .map((_, i) => ({ text: i, validate: jest.fn() }))

    const { getByText } = render(
      <Form>
        {validations.map((validation, index) => (
          <FormText
            key={index}
            validations={[validation]}
            label={index}
            defaultValue=""
          />
        ))}
        <Button>Submit</Button>
      </Form>
    )

    fireEvent.click(getByText('Submit'))

    validations.forEach(({ validate }) => expect(validate).toBeCalled)
  })

  it('calls props.onSubmit when all form elements are valid', () => {
    const validations = new Array(3)
      .fill()
      .map((_, i) => ({ text: i, validate: () => true }))
    const mockSubmit = jest.fn()

    const { getByText } = render(
      <Form onSubmit={mockSubmit}>
        {validations.map((validation, index) => (
          <FormText
            key={index}
            validations={[validation]}
            label={index}
            defaultValue=""
          />
        ))}
        <Button>Submit</Button>
      </Form>
    )

    fireEvent.click(getByText('Submit'))

    expect(mockSubmit).toBeCalled()
  })

  it(' does not call props.onSubmitValidationError when all form elements are valid', () => {
    const validations = new Array(3)
      .fill()
      .map((_, i) => ({ text: i, validate: () => true }))
    const mockSubmitValidationError = jest.fn()
    const mockSubmit = jest.fn()

    const { getByText } = render(
      <Form
        onSubmitValidationError={mockSubmitValidationError}
        onSubmit={mockSubmit}
      >
        {validations.map((validation, index) => (
          <FormText
            key={index}
            validations={[validation]}
            label={index}
            defaultValue=""
          />
        ))}
        <Button>Submit</Button>
      </Form>
    )

    fireEvent.click(getByText('Submit'))

    expect(mockSubmitValidationError).not.toBeCalled()
  })

  it('does not call props.onSubmit when some form elements are invalid', () => {
    const validations = new Array(3)
      .fill()
      .map((_, i) => ({ text: i, validate: () => false }))
    const mockSubmit = jest.fn()

    const { getByText } = render(
      <Form onSubmit={mockSubmit}>
        {validations.map((validation, index) => (
          <FormText
            key={index}
            validations={[validation]}
            label={index}
            defaultValue=""
          />
        ))}
        <Button>Submit</Button>
      </Form>
    )

    fireEvent.click(getByText('Submit'))

    expect(mockSubmit).not.toBeCalled()
  })

  it('calls props.onSubmitValidationError when some form elements are invalid', done => {
    const validations = new Array(3)
      .fill()
      .map((_, i) => ({ text: `Error - ${i}`, validate: () => false }))
    const mockSubmitValidationError = jest.fn()
    const mockSubmit = jest.fn()

    const { getByText } = render(
      <Form
        onSubmitValidationError={mockSubmitValidationError}
        onSubmit={mockSubmit}
      >
        {validations.map((validation, index) => (
          <FormText
            key={index}
            validations={[validation]}
            label={index}
            name={`field-${index}`}
            defaultValue=""
          />
        ))}
        <Button>Submit</Button>
      </Form>
    )

    fireEvent.click(getByText('Submit'))

    setTimeout(() => {
      expect(mockSubmitValidationError).toBeCalledWith([
        {
          name: 'field-0',
          value: '',
          isValid: false,
          messagesShown: [
            {
              messageText: 'Error - 0',
              messageKind: 'error'
            }
          ]
        },
        {
          name: 'field-1',
          value: '',
          isValid: false,
          messagesShown: [
            {
              messageText: 'Error - 1',
              messageKind: 'error'
            }
          ]
        },
        {
          name: 'field-2',
          value: '',
          isValid: false,
          messagesShown: [
            {
              messageText: 'Error - 2',
              messageKind: 'error'
            }
          ]
        }
      ])
      done()
    })
  })

  it('Focuses on the first invalid input in the form when submitted', done => {
    const { getByText, container } = render(
      <Form>
        <FormText label="Required Text" required />
        <Button>Submit</Button>
      </Form>
    )

    fireEvent.click(getByText('Submit'))
    const input = container.querySelector('input[name="requiredText"]')

    setTimeout(() => {
      expect(input).toHaveFocus()
      done()
    })
  })

  it('does not focus on any inputs on submit if all inputs are valid', done => {
    const { getByText, container } = render(
      <Form>
        <FormText label="Optional Text" defaultValue="text" />
        <Button>Submit</Button>
      </Form>
    )

    fireEvent.click(getByText('Submit'))

    const input = container.querySelector('input')

    setTimeout(() => {
      expect(input).not.toHaveFocus()
      done()
    })
  })

  it('handles form natively if no onSubmit callback is provided', done => {
    const mockHandleSubmit = jest.fn(event => {
      expect(event.defaultPrevented).toBeFalsy()
      expect(event.target.method).toBe('post')
      done()
    })
    document.addEventListener('submit', mockHandleSubmit)

    const { getByText, container } = render(
      <Form>
        <FormText label="Text" defaultValue="text" />
        <Button>Submit</Button>
      </Form>
    )

    fireEvent.click(getByText('Submit'))

    expect(mockHandleSubmit).toBeCalled()

    document.removeEventListener('submit', mockHandleSubmit)
  })

  it('handles form natively if allowDefault is true and there is an onSubmit', done => {
    const mockHandleSubmit = jest.fn(event => {
      expect(event.defaultPrevented).toBeFalsy()
      expect(event.target.method).toBe('post')
      done()
    })

    const mockSubmit = jest.fn()

    document.addEventListener('submit', mockHandleSubmit)

    const { getByText, container } = render(
      <Form onSubmit={mockSubmit} preventDefaultInOnSubmitProp={false}>
        <FormText label="Text" defaultValue="text" />
        <Button>Submit</Button>
      </Form>
    )

    fireEvent.click(getByText('Submit'))

    expect(mockSubmit).toBeCalled()
    expect(mockHandleSubmit).toBeCalled()

    document.removeEventListener('submit', mockHandleSubmit)
  })

  it('prevents default if there are validation errors', done => {
    const mockHandleSubmit = jest.fn(event => {
      expect(event.defaultPrevented).toBeTruthy()
      expect(event.target.method).toBe('post')
      done()
    })
    const mockSubmit = jest.fn()

    document.addEventListener('submit', mockHandleSubmit)

    const { getByText, container } = render(
      <Form onSubmit={mockSubmit} allowDefault>
        <FormText
          label="Text"
          defaultValue="text"
          validations={[{ text: 'Always Invalid', validate: () => false }]}
        />
        <Button>Submit</Button>
      </Form>
    )

    fireEvent.click(getByText('Submit'))

    expect(mockSubmit).not.toBeCalled()
    expect(mockHandleSubmit).toBeCalled()

    document.removeEventListener('submit', mockHandleSubmit)
  })

  it('provides access to form ref via props', () => {
    const formRef = React.createRef()

    const { container } = render(
      <Form formRef={formRef}>
        <FormText label="Text" />
        <Button>Submit</Button>
      </Form>
    )

    expect(formRef.current).toBe(container.querySelector('form'))
  })

  it('calls onValidation prop on validation event', () => {
    const onValidationFn = jest.fn()
    const { getByText, container } = render(
      <Form
        onValidationChange={({ target, detail: { messagesShown } }) =>
          onValidationFn(target, messagesShown)
        }
      >
        <FormText
          label="Text"
          value="some text"
          validations={[
            { text: 'Always Invalid', validate: () => false },
            { text: 'Always Valid', validate: () => true }
          ]}
        />
        <Button>Submit</Button>
      </Form>
    )
    fireEvent.click(getByText('Submit'))

    const expectedTarget = container.querySelector('input')

    expect(onValidationFn.mock.calls[0][0]).toBe(expectedTarget)
    expect(onValidationFn.mock.calls[0][1]).toEqual(['error', 'success'])
  })

  it('properly removes and adds event listeners when onValidation prop changes', () => {
    const onValidationFnOriginal = jest.fn()
    const onValidationFn = jest.fn()

    const { getByText, rerender } = render(
      <Form onValidationChange={onValidationFnOriginal}>
        <FormText
          label="Text"
          value="some text"
          validations={[{ text: 'Always Invalid', validate: () => false }]}
        />
        <Button>Submit</Button>
      </Form>
    )

    rerender(
      <Form onValidationChange={onValidationFn}>
        <FormText
          label="Text"
          value="some text"
          validations={[{ text: 'Always Invalid', validate: () => false }]}
        />
        <Button>Submit</Button>
      </Form>
    )

    fireEvent.click(getByText('Submit'))

    expect(onValidationFnOriginal).not.toBeCalled()
    expect(onValidationFn).toBeCalled()
  })

  it('calls onReset prop and clears validation messages on reset event', () => {
    const onResetFn = jest.fn()
    const formRef = React.createRef()
    const { getByLabelText, getByText, container } = render(
      <Form onReset={onResetFn} formRef={formRef}>
        <FormText
          label="Text"
          defaultValue="default text"
          validations={[
            { text: 'Always Invalid', validate: () => false },
            { text: 'Always Valid', validate: () => true }
          ]}
        />
        <Button>Submit</Button>
      </Form>
    )

    const input = getByLabelText('Text')

    fireEvent.focus(input)
    fireEvent.change(input, { target: { value: 'new' } })
    fireEvent.click(getByText('Submit'))

    const messages = container.querySelector('.kds-MessageGroup')

    expect(messages).toBeInTheDocument()

    fireEvent(formRef.current, new Event('reset'))

    expect(onResetFn).toBeCalled()
    expect(messages).not.toBeInTheDocument()
  })
})
