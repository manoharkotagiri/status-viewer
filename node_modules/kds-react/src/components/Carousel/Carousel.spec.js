import React from 'react'
import { render, fireEvent } from 'react-testing-library'
import Carousel from './Carousel'
import {
  getCarouselWidth,
  getTemplateWidth,
  getFirstTemplateElement,
  getFirstFullyVisibleElementIndex,
  getCarouselScrollPosition,
  getIsAtStartOfCarousel,
  getIsAtEndOfCarousel,
  scrollCarouselToPosition,
  focusCarouselItem,
  useCarouselOnScrollCallback,
  useCarouselOnPreviousButtonClickCallback,
  useCarouselOnNextButtonClickCallback,
  useOnSkipToStartButtonClickCallback,
  useOnSkipToEndButtonClickCallback,
  CAROUSEL_GRADIENT_WIDTH
} from './_carouselFunctions'
import { PaginationDots } from './_PaginationDots'

describe('Carousel', () => {
  const createMockCarouselWithTemplate = template => ({
    getBoundingClientRect: jest.fn().mockReturnValue({ width: 100 }),
    scrollLeft: 0,
    scroll: jest.fn(),
    querySelector: jest.fn().mockReturnValue({ children: [template] })
  })

  const mockCarousel = createMockCarouselWithTemplate({
    getBoundingClientRect: jest.fn().mockReturnValue({ width: 5 })
  })

  describe('getCarouselWidth', () => {
    it('should return 0 if carousel is undefined ', () => {
      expect(getCarouselWidth()).toEqual(0)
    })

    it('should return 0 if carousel.getBoundingClientRect is undefined ', () => {
      expect(
        getCarouselWidth({ ...mockCarousel, getBoundingClientRect: undefined })
      ).toEqual(0)
    })

    it('should return 0 if carousel.getBoundingClientRect is not a function ', () => {
      expect(
        getCarouselWidth({
          ...mockCarousel,
          getBoundingClientRect: 'getBoundingClientRect'
        })
      ).toEqual(0)
    })

    it('should return 0 if the total width of gradients is larger than the width of the carousel', () => {
      expect(
        getCarouselWidth({
          ...mockCarousel,
          getBoundingClientRect: jest.fn().mockReturnValue({ width: 1 })
        })
      ).toEqual(0)
    })

    it('should return carousel width minus the width of the gradients if carousel is defined and getBoundingClientRect is a function', () => {
      expect(
        getCarouselWidth({
          ...mockCarousel,
          getBoundingClientRect: jest.fn().mockReturnValue({ width: 100 })
        })
      ).toEqual(100 - 2 * CAROUSEL_GRADIENT_WIDTH)
    })
  })

  describe('getFirstTemplateElement', () => {
    it('should not break if carousel is undefined', () => {
      expect(getFirstTemplateElement()).toBeUndefined()
    })

    it('should select the correct template element', () => {
      const TestTemplate = ({ test }) => (
        <div data-test={`template-${test}`}>{test}</div>
      )

      const { container } = render(
        <Carousel
          template={TestTemplate}
          data={[
            { key: 1, test: 1 },
            { key: 2, test: 2 }
          ]}
        />
      )

      const carousel = container.querySelector('.kds-Carousel-contentWindow')
      const firstTemplateElement = getFirstTemplateElement(carousel)

      expect(firstTemplateElement.getAttribute('data-test')).toEqual(
        'template-1'
      )
    })
  })

  describe('getFirstFullyVisibleElementIndex', () => {
    it('should return 0 if carouselScrollPosition is 0', () => {
      expect(getFirstFullyVisibleElementIndex(0, 64)).toEqual(0)
    })

    it('should take gradient into account', () => {
      const templateWithGutterWidth = 64
      expect(
        getFirstFullyVisibleElementIndex(
          templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH + 1,
          templateWithGutterWidth
        )
      ).toEqual(2)
    })
  })

  describe('getTemplateWidth', () => {
    it('should return 0 if carousel is undefined', () => {
      expect(getTemplateWidth()).toEqual(0)
    })

    it('should return 0 if template is undefined', () => {
      expect(
        getTemplateWidth(createMockCarouselWithTemplate(undefined))
      ).toEqual(0)
    })

    it('should return 0 if template.getBoundingClientRect is undefined', () => {
      expect(
        getTemplateWidth(
          createMockCarouselWithTemplate({ getBoundingClientRect: undefined })
        )
      ).toEqual(0)
    })

    it('should return 0 if template.getBoundingClientRect is not a function', () => {
      expect(
        getTemplateWidth(
          createMockCarouselWithTemplate({
            getBoundingClientRect: 'getBoundingClientRect'
          })
        )
      ).toEqual(0)
    })

    it('should return template width if template.getBoundingClientRect is a function', () => {
      expect(
        getTemplateWidth(
          createMockCarouselWithTemplate({
            getBoundingClientRect: jest.fn().mockReturnValue({ width: 5 })
          })
        )
      ).toEqual(5)
    })
  })

  describe('getCarouselScrollPosition', () => {
    it('should return 0 if carousel is undefined', () => {
      expect(getCarouselScrollPosition()).toEqual(0)
    })

    it('should return 0 if carousel.scrollLeft is undefined', () => {
      expect(
        getCarouselScrollPosition({ ...mockCarousel, scrollLeft: undefined })
      ).toEqual(0)
    })

    it('should return carousel.scrollLeft if carousel is defined', () => {
      expect(
        getCarouselScrollPosition({ ...mockCarousel, scrollLeft: 10 })
      ).toEqual(10)
    })
  })

  describe('getIsAtStartOfCarousel', () => {
    it('should return true if carousel scroll position is 0', () => {
      expect(
        getIsAtStartOfCarousel({ ...mockCarousel, scrollLeft: 0 })
      ).toBeTruthy()
    })

    it('should return false if carousel scroll position is not 0', () => {
      expect(
        getIsAtStartOfCarousel({ ...mockCarousel, scrollLeft: 20 })
      ).toBeFalsy()
    })
  })

  describe('getIsAtEndOfCarousel', () => {
    it('should return false if carousel scroll position is less than the container width minus the total carousel width', () => {
      const carouselToTest = {
        ...mockCarousel,
        scrollLeft: 99,
        getBoundingClientRect: jest.fn().mockReturnValue({ width: 100 })
      }

      const containerWidth = 200

      expect(getIsAtEndOfCarousel(carouselToTest, containerWidth)).toBeFalsy()
    })

    it('should return true if carousel scroll position is equal to the container width minus the total carousel width', () => {
      const carouselToTest = {
        ...mockCarousel,
        scrollLeft: 100,
        getBoundingClientRect: jest.fn().mockReturnValue({ width: 100 })
      }

      const containerWidth = 200

      expect(getIsAtEndOfCarousel(carouselToTest, containerWidth)).toBeTruthy()
    })

    it('should return true if carousel scroll position is greater than the container width minus the total carousel width', () => {
      const carouselToTest = {
        ...mockCarousel,
        scrollLeft: 115,
        getBoundingClientRect: jest.fn().mockReturnValue({ width: 100 })
      }

      const containerWidth = 200

      expect(getIsAtEndOfCarousel(carouselToTest, containerWidth)).toBeTruthy()
    })
  })

  describe('scrollCarouselToPosition', () => {
    it('should not break if carousel is undefined', () => {
      scrollCarouselToPosition()
    })

    it('should call carousel.scroll with correct value if carousel.scroll is a function', () => {
      const mockScroll = jest.fn()
      const carouselToTest = { ...mockCarousel, scroll: mockScroll }
      scrollCarouselToPosition(carouselToTest, 15)
      expect(mockScroll).toHaveBeenCalledTimes(1)
      expect(mockScroll).toHaveBeenCalledWith(15, 0)
    })

    it('should set carousel.scrollLeft to correct value if carousel.scroll is not a function', () => {
      const carouselToTest = {
        ...mockCarousel,
        scrollLeft: 0,
        scroll: undefined
      }
      expect(carouselToTest.scrollLeft).toEqual(0)
      scrollCarouselToPosition(carouselToTest, 15)
      expect(carouselToTest.scrollLeft).toEqual(15)
    })
  })

  describe('focusCarouselItem', () => {
    it('should not break if carousel or indexToFocus is undefined', () => {
      focusCarouselItem()
    })

    it('should not break if item to be focused is not in DOM', () => {
      const TestTemplate = ({ test }) => (
        <div data-test={`template-${test}`}>{test}</div>
      )

      const { container } = render(
        <Carousel
          template={TestTemplate}
          data={[
            { key: 1, test: 1 },
            { key: 2, test: 2 },
            { key: 3, test: 3 },
            { key: 4, test: 4 },
            { key: 5, test: 5 },
            { key: 6, test: 6 },
            { key: 7, test: 7 },
            { key: 8, test: 8 }
          ]}
        />
      )

      const carousel = container.querySelector('.kds-Carousel-contentWindow')
      const listItems = carousel.querySelectorAll('.kds-Carousel-item')
      const indexToFocus = 6

      expect(listItems[indexToFocus]).toBeFalsy()

      focusCarouselItem(carousel, indexToFocus)
    })

    it('should focus the correct item if it is in the DOM', () => {
      const TestTemplate = ({ test }) => (
        <div data-test={`template-${test}`}>{test}</div>
      )

      const { container } = render(
        <Carousel
          template={TestTemplate}
          data={[
            { key: 1, test: 1 },
            { key: 2, test: 2 },
            { key: 3, test: 3 },
            { key: 4, test: 4 },
            { key: 5, test: 5 },
            { key: 6, test: 6 },
            { key: 7, test: 7 },
            { key: 8, test: 8 }
          ]}
        />
      )

      const carousel = container.querySelector('.kds-Carousel-contentWindow')
      const listItems = carousel.querySelectorAll('.kds-Carousel-item')
      const indexToFocus = 2

      focusCarouselItem(carousel, indexToFocus)

      expect(listItems[indexToFocus]).toBeInTheDocument()
      expect(listItems[indexToFocus]).toHaveFocus()
    })
  })

  describe('useCarouselOnScrollCallback', () => {
    const mockSetFirstFullyVisibleElementIndex = jest.fn()
    const mockForceUpdate = jest.fn()

    const TestComp = ({ carousel }) => {
      const onScroll = useCarouselOnScrollCallback({
        carousel,
        containerWidth: 400,
        templateWithGutterWidth: 40,
        firstFullyVisibleElementIndex: 0,
        setFirstFullyVisibleElementIndex: mockSetFirstFullyVisibleElementIndex,
        forceUpdate: mockForceUpdate,
        previousIsAtEndOfCarousel: false
      })

      return <div onScroll={onScroll}>test</div>
    }

    afterEach(() => {
      jest.clearAllMocks()
    })

    it('should not break if carousel is undefined', () => {
      const { container } = render(<TestComp carousel={undefined} />)

      fireEvent(container.firstChild, new Event('scroll'))

      expect(mockSetFirstFullyVisibleElementIndex).not.toHaveBeenCalled()
      expect(mockForceUpdate).not.toHaveBeenCalled()
    })

    it('should not call setFirstFullyVisibleElementIndex if the firstFullyVisibleElementIndex has not changed', () => {
      const { container } = render(
        <TestComp
          carousel={createMockCarouselWithTemplate({
            getBoundingClientRect: jest.fn().mockReturnValue({ width: 5 })
          })}
        />
      )

      mockCarousel.scrollLeft = 0
      fireEvent.scroll(container.firstChild)

      expect(mockSetFirstFullyVisibleElementIndex).not.toHaveBeenCalled()
      expect(mockForceUpdate).not.toHaveBeenCalled()
    })

    it('should call setFirstFullyVisibleElementIndex if the firstFullyVisibleElementIndex has changed', () => {
      const mockCarousel = createMockCarouselWithTemplate({
        getBoundingClientRect: jest.fn().mockReturnValue({ width: 5 })
      })
      const { container } = render(<TestComp carousel={mockCarousel} />)

      mockCarousel.scrollLeft = 1
      fireEvent.scroll(container.firstChild)

      expect(mockSetFirstFullyVisibleElementIndex).toHaveBeenCalledTimes(1)
      expect(mockSetFirstFullyVisibleElementIndex).toHaveBeenCalledWith(1)
      expect(mockForceUpdate).not.toHaveBeenCalled()
    })

    it('should call forceUpdate when we reach the end of the carousel but the firstFullyVisibleElement index hasnt changed', () => {
      const carouselToTest = {
        ...mockCarousel,
        getBoundingClientRect: jest
          .fn()
          .mockReturnValue({ width: 200 + 2 * CAROUSEL_GRADIENT_WIDTH }),
        scrollLeft: 200 - 2 * CAROUSEL_GRADIENT_WIDTH - 1
      }
      const TestComp2 = () => {
        const onScroll = useCarouselOnScrollCallback({
          carousel: carouselToTest,
          containerWidth: 400,
          templateWithGutterWidth: 40,
          firstFullyVisibleElementIndex: 5,
          setFirstFullyVisibleElementIndex: mockSetFirstFullyVisibleElementIndex,
          forceUpdate: mockForceUpdate,
          previousIsAtEndOfCarousel: false
        })

        return <div onScroll={onScroll}>test</div>
      }
      const { container } = render(<TestComp2 carousel={mockCarousel} />)

      carouselToTest.scrollLeft = 200 - 2 * CAROUSEL_GRADIENT_WIDTH
      fireEvent.scroll(container.firstChild)

      expect(mockSetFirstFullyVisibleElementIndex).not.toHaveBeenCalled()
      expect(mockForceUpdate).toHaveBeenCalledTimes(1)
    })

    it('should call forceUpdate when we are no longer at the end of the carousel but the firstFullyVisibleElement index hasnt changed', () => {
      const carouselToTest = {
        ...mockCarousel,
        getBoundingClientRect: jest
          .fn()
          .mockReturnValue({ width: 200 + 2 * CAROUSEL_GRADIENT_WIDTH }),
        scrollLeft: 200 - 2 * CAROUSEL_GRADIENT_WIDTH
      }
      const TestComp2 = () => {
        const onScroll = useCarouselOnScrollCallback({
          carousel: carouselToTest,
          containerWidth: 400,
          templateWithGutterWidth: 40,
          firstFullyVisibleElementIndex: 5,
          setFirstFullyVisibleElementIndex: mockSetFirstFullyVisibleElementIndex,
          forceUpdate: mockForceUpdate,
          previousIsAtEndOfCarousel: true
        })

        return <div onScroll={onScroll}>test</div>
      }
      const { container } = render(<TestComp2 carousel={mockCarousel} />)

      carouselToTest.scrollLeft = 200 - 2 * CAROUSEL_GRADIENT_WIDTH - 1
      fireEvent.scroll(container.firstChild)

      expect(mockSetFirstFullyVisibleElementIndex).not.toHaveBeenCalled()
      expect(mockForceUpdate).toHaveBeenCalledTimes(1)
    })
  })

  describe('useCarouselOnPreviousButtonClickCallback', () => {
    const mockCarouselScroll = jest.fn()
    const templateWithGutterWidth = 40

    const TestComp = ({ carousel, containerWidth }) => {
      const onClick = useCarouselOnPreviousButtonClickCallback({
        carousel,
        containerWidth,
        templateWithGutterWidth,
        numberOfItemsShown: 2
      })

      return <button onClick={onClick}>test</button>
    }

    afterEach(() => {
      jest.clearAllMocks()
    })

    it('should not break if carousel is undefined', () => {
      const { container } = render(<TestComp carousel={undefined} />)

      fireEvent.click(container.firstChild)
    })

    it('should not scroll past a partially hidden element', () => {
      const carouselToTest = {
        scrollLeft: 2 * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH + 1, // third element is barely hidden
        scroll: mockCarouselScroll
      }
      const { container } = render(<TestComp carousel={carouselToTest} />)

      fireEvent.click(container.firstChild)
      expect(mockCarouselScroll).toHaveBeenCalledTimes(1)
      expect(mockCarouselScroll).toHaveBeenCalledWith(
        templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH, // second and third element completely in view
        0
      )
    })

    it('should scroll past the first visible element if it is completely in view', () => {
      const carouselToTest = {
        scrollLeft: 2 * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH, // third element in view
        scroll: mockCarouselScroll
      }
      const { container } = render(<TestComp carousel={carouselToTest} />)

      fireEvent.click(container.firstChild)
      expect(mockCarouselScroll).toHaveBeenCalledTimes(1)
      expect(mockCarouselScroll).toHaveBeenCalledWith(
        0 - CAROUSEL_GRADIENT_WIDTH,
        0
      )
    })

    it('should scroll to the start of the previous section if we are at the end of the carousel but dont have enough items to take up a full last section', () => {
      const scrollLeft = 3 * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH // third and fourth element in view

      const carouselToTest = {
        scrollLeft,
        scroll: mockCarouselScroll,
        getBoundingClientRect: jest.fn().mockReturnValue({ width: 100 })
      }

      const containerWidth = scrollLeft + 100

      const { container } = render(
        <TestComp carousel={carouselToTest} containerWidth={containerWidth} />
      )

      fireEvent.click(container.firstChild)
      expect(mockCarouselScroll).toHaveBeenCalledTimes(1)
      expect(mockCarouselScroll).toHaveBeenCalledWith(
        2 * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH, // second and third
        0
      )
    })

    it('should scroll to the start of the previous section if we are at the end of the carousel and have enough items to take up a full last section', () => {
      const scrollLeft = 4 * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH // third and fourth element in view

      const carouselToTest = {
        scrollLeft,
        scroll: mockCarouselScroll,
        getBoundingClientRect: jest.fn().mockReturnValue({ width: 100 })
      }

      const containerWidth = scrollLeft + 100

      const { container } = render(
        <TestComp carousel={carouselToTest} containerWidth={containerWidth} />
      )

      fireEvent.click(container.firstChild)
      expect(mockCarouselScroll).toHaveBeenCalledTimes(1)
      expect(mockCarouselScroll).toHaveBeenCalledWith(
        2 * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH, // second and third are in view
        0
      )
    })
  })

  describe('useCarouselOnNextButtonClickCallback', () => {
    const mockCarouselScroll = jest.fn()
    const templateWithGutterWidth = 40

    const TestComp = ({ carousel }) => {
      const onClick = useCarouselOnNextButtonClickCallback({
        carousel,
        templateWithGutterWidth,
        numberOfItemsShown: 2,
        templateWidth: 38
      })

      return <button onClick={onClick}>test</button>
    }

    afterEach(() => {
      jest.clearAllMocks()
    })

    it('should not break if carousel is undefined', () => {
      const { container } = render(<TestComp carousel={undefined} />)

      fireEvent.click(container.firstChild)
    })

    it('should not scroll past a partially hidden element', () => {
      const carouselToTest = {
        getBoundingClientRect: jest.fn().mockReturnValue({
          width: 2 * templateWithGutterWidth + 2 * CAROUSEL_GRADIENT_WIDTH + 1
        }),
        scrollLeft: templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH, // second and third are completely in view, 1px of the 4th is shown
        scroll: mockCarouselScroll
      }
      const { container } = render(<TestComp carousel={carouselToTest} />)

      fireEvent.click(container.firstChild)
      expect(mockCarouselScroll).toHaveBeenCalledTimes(1)
      expect(mockCarouselScroll).toHaveBeenCalledWith(
        3 * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH, // scroll to fourth element
        0
      )
    })

    it('should scroll past the last element if it is completely in view', () => {
      const carouselToTest = {
        getBoundingClientRect: jest.fn().mockReturnValue({
          width: 2 * templateWithGutterWidth + 2 * CAROUSEL_GRADIENT_WIDTH + 1
        }),
        scrollLeft: templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH - 1, // third element is just in view
        scroll: mockCarouselScroll
      }
      const { container } = render(<TestComp carousel={carouselToTest} />)

      fireEvent.click(container.firstChild)
      expect(mockCarouselScroll).toHaveBeenCalledTimes(1)
      expect(mockCarouselScroll).toHaveBeenCalledWith(
        3 * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH, // scroll to fourth element
        0
      )
    })

    it('should scroll past the last element if it is completely in view but the margin after it is not', () => {
      const carouselToTest = {
        getBoundingClientRect: jest.fn().mockReturnValue({
          width: 2 * templateWithGutterWidth + 2 * CAROUSEL_GRADIENT_WIDTH + 1
        }),
        scrollLeft: templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH - 2, // 1px of third elements marginRight is hidden
        scroll: mockCarouselScroll
      }
      const { container } = render(<TestComp carousel={carouselToTest} />)

      fireEvent.click(container.firstChild)
      expect(mockCarouselScroll).toHaveBeenCalledTimes(1)
      expect(mockCarouselScroll).toHaveBeenCalledWith(
        3 * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH, // scroll to fourth element
        0
      )
    })
  })

  describe('useOnSkipToStartButtonClickCallback', () => {
    const mockCarouselScroll = jest.fn()
    const templateWithGutterWidth = 40

    const TestComp = ({ carousel }) => {
      const onClick = useOnSkipToStartButtonClickCallback({
        carousel
      })

      return <button onClick={onClick}>test</button>
    }

    afterEach(() => {
      jest.clearAllMocks()
    })

    it('should not break if carousel is undefined', () => {
      const { container } = render(<TestComp carousel={undefined} />)

      fireEvent.click(container.firstChild)
    })

    it('should scroll to the start of the carousel if not already at the start of the carousel', () => {
      const scrollLeft = 3 * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH // third and fourth element in view

      const carouselToTest = {
        scrollLeft,
        scroll: mockCarouselScroll,
        getBoundingClientRect: jest.fn().mockReturnValue({ width: 100 })
      }

      const containerWidth = scrollLeft + 100

      const { container } = render(
        <TestComp carousel={carouselToTest} containerWidth={containerWidth} />
      )

      fireEvent.click(container.firstChild)
      expect(mockCarouselScroll).toHaveBeenCalledTimes(1)
      expect(mockCarouselScroll).toHaveBeenCalledWith(
        0, // start of carousel
        0
      )
    })

    it('should focus first item without scrolling if already at the start of the carousel', () => {
      const scrollLeft = 0 // start of carousel
      const mockFocusCarouselItem = jest.fn()
      const mockCarouselQuerySelector = jest
        .fn()
        .mockReturnValue({ focus: mockFocusCarouselItem })

      const carouselToTest = {
        scrollLeft,
        scroll: mockCarouselScroll,
        getBoundingClientRect: jest.fn().mockReturnValue({ width: 100 }),
        querySelector: mockCarouselQuerySelector
      }

      const containerWidth = scrollLeft + 100

      const { container } = render(
        <TestComp carousel={carouselToTest} containerWidth={containerWidth} />
      )

      fireEvent.click(container.firstChild)
      expect(mockCarouselScroll).toHaveBeenCalledTimes(0)
      expect(mockCarouselQuerySelector).toHaveBeenCalledWith(
        '[aria-posinset="1"]'
      )
      expect(mockFocusCarouselItem).toHaveBeenCalledTimes(1)
    })
  })

  describe('useOnSkipToEndButtonClickCallback', () => {
    const mockCarouselScroll = jest.fn()
    const templateWithGutterWidth = 40
    const totalNumberOfItems = 3

    const TestComp = ({ carousel }) => {
      const onClick = useOnSkipToEndButtonClickCallback({
        carousel,
        templateWithGutterWidth,
        totalNumberOfItems
      })

      return <button onClick={onClick}>test</button>
    }

    afterEach(() => {
      jest.clearAllMocks()
    })

    it('should not break if carousel is undefined', () => {
      const { container } = render(<TestComp carousel={undefined} />)

      fireEvent.click(container.firstChild)
    })

    it('should scroll to the end of the carousel if not already at the end of the carousel', () => {
      const scrollLeft = 0

      const carouselToTest = {
        scrollLeft: 0,
        scroll: mockCarouselScroll,
        getBoundingClientRect: jest.fn().mockReturnValue({ width: 100 })
      }

      const containerWidth = scrollLeft + 100

      const { container } = render(
        <TestComp carousel={carouselToTest} containerWidth={containerWidth} />
      )

      fireEvent.click(container.firstChild)
      expect(mockCarouselScroll).toHaveBeenCalledTimes(1)
      expect(mockCarouselScroll).toHaveBeenCalledWith(
        totalNumberOfItems * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH, // end of carousel
        0
      )
    })

    it('should focus last item without scrolling if already at the end of the carousel', () => {
      const scrollLeft =
        totalNumberOfItems * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH // end of carousel
      const mockFocusCarouselItem = jest.fn()
      const mockCarouselQuerySelector = jest
        .fn()
        .mockReturnValue({ focus: mockFocusCarouselItem })

      const carouselToTest = {
        scrollLeft,
        scroll: mockCarouselScroll,
        getBoundingClientRect: jest.fn().mockReturnValue({ width: 100 }),
        querySelector: mockCarouselQuerySelector
      }

      const containerWidth = scrollLeft + 100

      const TestComponent = ({ carousel }) => {
        const onClick = useOnSkipToEndButtonClickCallback({
          carousel,
          templateWithGutterWidth,
          totalNumberOfItems,
          containerWidth
        })

        return <button onClick={onClick}>test</button>
      }

      const { container } = render(
        <TestComponent
          carousel={carouselToTest}
          containerWidth={containerWidth}
        />
      )

      fireEvent.click(container.firstChild)
      expect(mockCarouselScroll).toHaveBeenCalledTimes(0)
      expect(mockCarouselQuerySelector).toHaveBeenCalledWith(
        '[aria-posinset="3"]'
      )
      expect(mockFocusCarouselItem).toHaveBeenCalledTimes(1)
    })
  })

  it('should not display gradients when hideGradients prop is true', () => {
    const TestTemplate = ({ test }) => (
      <div data-test={`template-${test}`}>{test}</div>
    )

    const { container } = render(
      <Carousel
        hideGradients
        template={TestTemplate}
        data={[
          { key: 1, test: 1 },
          { key: 2, test: 2 },
          { key: 3, test: 3 },
          { key: 4, test: 4 },
          { key: 5, test: 5 },
          { key: 6, test: 6 },
          { key: 7, test: 7 },
          { key: 8, test: 8 },
          { key: 9, test: 9 },
          { key: 10, test: 10 },
          { key: 11, test: 11 },
          { key: 12, test: 12 },
          { key: 13, test: 13 },
          { key: 14, test: 14 },
          { key: 15, test: 15 },
          { key: 16, test: 16 },
          { key: 17, test: 17 },
          { key: 18, test: 18 },
          { key: 19, test: 19 },
          { key: 20, test: 20 }
        ]}
      />
    )

    const gradientContainer = container.querySelector(
      '.kds-Carousel-gradientContainer'
    )

    expect(gradientContainer).toHaveClass('kds-Carousel-hideStartGradient')
    expect(gradientContainer).toHaveClass('kds-Carousel-hideEndGradient')
  })
})

describe('PaginationDots', () => {
  it('should return null if numberOfSections is less than 2', () => {
    const { container } = render(
      <PaginationDots numberOfSections={1} currentSection={1} />
    )

    expect(container.firstChild).toBeFalsy()
  })

  it('should return null if numberOfSections is greater than 10', () => {
    const { container } = render(
      <PaginationDots numberOfSections={11} currentSection={1} />
    )

    expect(container.firstChild).toBeFalsy()
  })

  it('should render an amount of dots equal to the number of sections and set special styles on the currentSection', () => {
    const { container } = render(
      <PaginationDots numberOfSections={3} currentSection={2} />
    )

    expect(container.firstChild).toMatchInlineSnapshot(`
<div
  class="kds-Carousel-indicators"
>
  <div
    class="kds-Carousel-indicator"
  />
  <div
    class="kds-Carousel-indicator kds-Carousel-indicator--active"
  />
  <div
    class="kds-Carousel-indicator"
  />
</div>
`)
  })
})
