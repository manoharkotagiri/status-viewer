import { useCallback } from 'react'
import { isFunction } from 'lodash/fp'
import { debounce } from '../../utils/functionUtils'

export const CAROUSEL_GUTTER_WIDTH = 16
export const CAROUSEL_GRADIENT_WIDTH = 32

export const getCarouselWidth = carousel => {
  let carouselWidth = 0
  if (carousel && isFunction(carousel.getBoundingClientRect)) {
    const {
      width: carouselWidthWithGradients
    } = carousel.getBoundingClientRect()
    carouselWidth = carouselWidthWithGradients - CAROUSEL_GRADIENT_WIDTH * 2
  }
  return Math.max(0, carouselWidth)
}

export const getFirstTemplateElement = carousel =>
  carousel && carousel.querySelector('[data-itemindex]').children[0]

export const getTemplateWidth = carousel => {
  let templateWidth = 0
  // NOTE: This only works if all template components have the same width. we are okay with this for MVP
  const firstTemplateElement = getFirstTemplateElement(carousel)

  if (
    firstTemplateElement &&
    isFunction(firstTemplateElement.getBoundingClientRect)
  ) {
    ;({ width: templateWidth } = firstTemplateElement.getBoundingClientRect())
  }

  return templateWidth
}

export const getNumberOfItemsShown = (carouselWidth, templateWithGutterWidth) =>
  Math.max(
    Math.floor(
      // we add CAROUSEL_GUTTER_WIDTH here because we want to handle the scenario where the last
      // item is completely in view but the margin after it is not
      (carouselWidth + CAROUSEL_GUTTER_WIDTH) / templateWithGutterWidth
    ),
    1
  ) // we also want it to not break completely if the template elements are wider than the carousel

export const getFullContainerWidth = (
  templateWithGutterWidth,
  totalNumberOfItems
) =>
  templateWithGutterWidth * totalNumberOfItems -
  CAROUSEL_GUTTER_WIDTH /* this is: (the width of all template elements + marginRight on each of them) -
  (gutter width/margin since the last element has no marginRight) */

export const getStartIndexToRender = (
  firstFullyVisibleElementIndex,
  numberOfItemsShown
) => Math.max(0, firstFullyVisibleElementIndex - numberOfItemsShown)

export const getEndIndexToRender = (
  totalNumberOfItems,
  firstFullyVisibleElementIndex,
  numberOfItemsShown
) =>
  Math.min(
    totalNumberOfItems,
    firstFullyVisibleElementIndex + numberOfItemsShown * 2 + 1
  )

export const getNumberOfSections = (
  carouselWidth,
  totalNumberOfItems,
  numberOfItemsShown
) =>
  carouselWidth === 0 ? 0 : Math.ceil(totalNumberOfItems / numberOfItemsShown)

export const getCurrentSection = (
  firstFullyVisibleElementIndex,
  numberOfItemsShown,
  numberOfSections,
  isAtEndOfCarousel,
  totalNumberOfItems
) =>
  isAtEndOfCarousel ||
  firstFullyVisibleElementIndex + numberOfItemsShown >= totalNumberOfItems
    ? numberOfSections
    : Math.min(
      Math.floor(firstFullyVisibleElementIndex / numberOfItemsShown) + 1,
      numberOfSections
    )

export const getCarouselScrollPosition = carousel =>
  (carousel && carousel.scrollLeft) || 0

export const getIsAtStartOfCarousel = carousel =>
  getCarouselScrollPosition(carousel) === 0

export const getIsAtEndOfCarousel = (carousel, containerWidth) => {
  const carouselScrollPosition = getCarouselScrollPosition(carousel)
  const carouselWidth = getCarouselWidth(carousel)

  return (
    carouselScrollPosition >=
    containerWidth - (carouselWidth + 2 * CAROUSEL_GRADIENT_WIDTH)
  )
}

export const getFirstFullyVisibleElementIndex = (
  carouselScrollPosition,
  templateWithGutterWidth
) =>
  carouselScrollPosition === 0
    ? 0
    : Math.ceil(
      (carouselScrollPosition + CAROUSEL_GRADIENT_WIDTH) /
          templateWithGutterWidth
    )

export const scrollCarouselToPosition = (carousel, scrollToPosition) => {
  if (!carousel) {
    return
  }

  if (isFunction(carousel.scroll)) {
    carousel.scroll(scrollToPosition, 0)
  } else {
    // edge does not support el.scroll(), so we need to fall back to setting scrollLeft for certain browsers
    carousel.scrollLeft = scrollToPosition
  }
}

export const focusCarouselItem = (carousel, indexToFocus) => {
  if (!carousel) {
    return
  }

  const itemToFocus = carousel.querySelector(
    `[aria-posinset="${indexToFocus + 1}"]`
  )

  itemToFocus && itemToFocus.focus()
}

export const focusCarouselItemAfterScrolling = (carousel, indexToFocus) => {
  if (!carousel) {
    return
  }

  // Check that carousel has stopped scrolling first
  // Make sure element supports addEventListener
  const isSupported = carousel.addEventListener
  if (!isSupported) return

  // Create event listener that calls handler after carousel has stopped scrolling
  const scrollListener = debounce(() => {
    focusCarouselItem(carousel, indexToFocus)
    // Remove event listener
    carousel.removeEventListener('scroll', scrollListener)
  }, 100)

  // Add event listener
  carousel.addEventListener('scroll', scrollListener)
}

export const useCarouselOnScrollCallback = ({
  carousel,
  containerWidth,
  templateWithGutterWidth,
  firstFullyVisibleElementIndex,
  setFirstFullyVisibleElementIndex,
  forceUpdate,
  previousIsAtEndOfCarousel
}) =>
  useCallback(() => {
    if (!carousel) {
      return
    }

    const carouselScrollPosition = getCarouselScrollPosition(carousel)

    const newFirstFullyVisibleElementIndex = getFirstFullyVisibleElementIndex(
      carouselScrollPosition,
      templateWithGutterWidth
    )

    if (newFirstFullyVisibleElementIndex !== firstFullyVisibleElementIndex) {
      setFirstFullyVisibleElementIndex(newFirstFullyVisibleElementIndex)
      return
    }

    if (
      getIsAtEndOfCarousel(carousel, containerWidth) !==
      previousIsAtEndOfCarousel
    ) {
      // we need to call this because we aren't guaranteed that firstFullyVisibleElement
      //  will change when we're at the end of the carousel
      forceUpdate()
    }
  }, [
    carousel,
    containerWidth,
    firstFullyVisibleElementIndex,
    templateWithGutterWidth,
    setFirstFullyVisibleElementIndex,
    forceUpdate,
    previousIsAtEndOfCarousel
  ])

export const useCarouselOnPreviousButtonClickCallback = ({
  carousel,
  containerWidth,
  templateWithGutterWidth,
  numberOfItemsShown
}) =>
  useCallback(() => {
    if (!carousel) {
      return
    }
    const carouselScrollPosition = getCarouselScrollPosition(carousel)

    const firstFullyVisibleElementIndex = getFirstFullyVisibleElementIndex(
      carouselScrollPosition,
      templateWithGutterWidth
    )

    let numberOfItemsToScroll = numberOfItemsShown

    if (getIsAtEndOfCarousel(carousel, containerWidth)) {
      // if the number of items in the carousel is not a perfect multiple of the numberOfItemsShown,
      // we want to make sure the pagination dots don't get messed up as the user navigates back
      // through the carousel
      numberOfItemsToScroll =
        firstFullyVisibleElementIndex % numberOfItemsShown || numberOfItemsShown
    }

    const indexToScrollTo =
      firstFullyVisibleElementIndex - numberOfItemsToScroll

    const scrollToPosition =
      indexToScrollTo * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH

    scrollCarouselToPosition(carousel, scrollToPosition)
  }, [carousel, containerWidth, templateWithGutterWidth, numberOfItemsShown])

export const useCarouselOnNextButtonClickCallback = ({
  carousel,
  templateWithGutterWidth,
  templateWidth,
  numberOfItemsShown
}) =>
  useCallback(() => {
    if (!carousel) {
      return
    }

    const carouselScrollPosition = getCarouselScrollPosition(carousel)
    const carouselWidth = getCarouselWidth(carousel)

    const firstPartiallyVisibleElementIndex = Math.floor(
      (carouselScrollPosition + CAROUSEL_GRADIENT_WIDTH) /
        templateWithGutterWidth
    )

    const indexToScrollTo =
      firstPartiallyVisibleElementIndex + numberOfItemsShown

    let scrollToPosition =
      indexToScrollTo * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH

    // this is to account for the scenario where the next index is already in view, but the gutter after it is not
    const isIndexToScrollToAlreadyInView =
      scrollToPosition - carouselScrollPosition + templateWidth <= carouselWidth

    if (isIndexToScrollToAlreadyInView) {
      scrollToPosition =
        (indexToScrollTo + 1) * templateWithGutterWidth -
        CAROUSEL_GRADIENT_WIDTH
    }

    scrollCarouselToPosition(carousel, scrollToPosition)
  }, [carousel, templateWithGutterWidth, templateWidth, numberOfItemsShown])

export const useOnSkipToStartButtonClickCallback = ({ carousel }) =>
  useCallback(() => {
    if (!carousel) {
      return
    }

    if (getIsAtStartOfCarousel(carousel)) {
      focusCarouselItem(carousel, 0)
      return
    }

    scrollCarouselToPosition(carousel, 0)
    focusCarouselItemAfterScrolling(carousel, 0)
  }, [carousel])

export const useOnSkipToEndButtonClickCallback = ({
  carousel,
  templateWithGutterWidth,
  totalNumberOfItems,
  containerWidth
}) =>
  useCallback(() => {
    if (!carousel) {
      return
    }

    if (getIsAtEndOfCarousel(carousel, containerWidth)) {
      focusCarouselItem(carousel, totalNumberOfItems - 1)
      return
    }

    const scrollToPosition =
      totalNumberOfItems * templateWithGutterWidth - CAROUSEL_GRADIENT_WIDTH

    scrollCarouselToPosition(carousel, scrollToPosition)
    focusCarouselItemAfterScrolling(carousel, totalNumberOfItems - 1)
  }, [carousel, templateWithGutterWidth, totalNumberOfItems, containerWidth])
