import React, { PureComponent } from 'react'
import PropTypes from 'prop-types'
import cx from 'classnames'
import Button from '../Button/Button'
import Text from '../Text/Text'
import { IconMinus, IconPlus, IconTrash } from '../Icon/index'
import { generateUniqueString } from '../../utils/generationUtils'

function parseInteger (value) {
  return Math.max(parseInt(value) || 0, 0)
}

function snapValue (oldValue, newValue, minQty, max) {
  newValue = parseInteger(newValue)
  let value = oldValue
  if (minQty <= newValue && newValue <= max) {
    value = newValue
  } else if (newValue > max) {
    value = max
  } else if (newValue < minQty) {
    const direction = newValue - value
    value =
      direction > 0
        ? minQty // This means we're adding, snap to minimum quantity
        : 0 // if we're subtracting, snap to zero
  }
  return value
}

function focusRef (ref) {
  ref &&
    ref.current &&
    typeof ref.current.focus === 'function' &&
    setTimeout(() => ref.current && ref.current.focus()) // made asynchronous to prevent triggering CTA click event when focused on from manualy entering value of 0
}

const kinds = ['primary', 'secondary']

/**
 * `QuantityStepper` lets users increment and decrement quantities. Use them for things like adding/removing items to/from a cart or list.
 *
 * QuantityStepper updates optimistically by updating local state immediately and triggering `onChange` callback passing current value from local state.
 *
 * **It is the responsibility of the consumer to debounce/handle any necessary resolutions for any functions or async requests triggered by `onChange`**
 *
 * Because it wraps the buttons and input in a `div`, additional props will be spread onto the `div`.
 *
 * > ```Message { "props": { "kind": "warning" } }
 * > *THIS COMPONENT IS EXPERIMENTAL.*
 * >
 */

class QuantityStepper extends PureComponent {
  static propTypes = {
    /** Name of the item, ingredient, or whatever thing is being incremented / decremented. Incorporated — along with `callToAction` and/or `description` if provided — into informative output for ARIA attributes. */
    what: PropTypes.string.isRequired,
    /** Pass utility classes to the container element */
    className: PropTypes.string,
    /** Function to execute whenever input value changes, triggered on:
     *
     * - **click** CTA/Increment/Decrement buttons
     * - **keydown** *Enter* key when focused on Input field
     * - **blur** from input field after manual entry change
     *
     * > **Note:** `onChange` will fire multiple times when these actions occur successively with value change
     *
     * @param { number } value The updated value of the stepper
     * @param { number } prevValue The previous value of the stepper
     * @param { object } event The event object
     */
    onChange: PropTypes.func,
    /** Renders compact buttons. */
    compact: PropTypes.bool,
    /** Renders a "Call-To-Action" button with the provided text (e.g. `"Add to Cart"`). If provided, the stepper displays a button when the value is 0. Must be title case per KDS Guidelines. */
    callToAction: PropTypes.string,
    /** Props to set on call to action button. */
    callToActionProps: PropTypes.object,
    /** Props to set on decrement button. */
    decButtonProps: PropTypes.object,
    /** Renders a small descriptive block below the quantity input field. */
    description: PropTypes.string,
    /** Changes styling of decrement button to "secondary-negative" when value is `<=1`. */
    destructive: PropTypes.bool,
    /** Displays a disabled QuantityStepper */
    disabled: PropTypes.bool,
    /** Horizontally centers QuantityStepper and makes "Call-To-Action" button full-width. */
    fullWidth: PropTypes.bool,
    /** Props to set on increment button. */
    incButtonProps: PropTypes.object,
    /** Optional maximum number. Must be a positive integer. Values exceeding max will be snapped max when decrementing/incrementing. */
    max: PropTypes.number,
    /** Defines how many items will be added when the increment button is first clicked. Also determines where the value changes to zero on decrement. */
    minimumQuantity: PropTypes.number,
    /** Sets/Updates the internal value of the stepper when changed. */
    value: PropTypes.number,
    /** Determines the CTA button appearance. */
    kind: PropTypes.oneOf(kinds)
  }

  static defaultProps = {
    callToAction: '',
    callToActionProps: {},
    compact: false,
    decButtonProps: {},
    description: '',
    destructive: false,
    disabled: false,
    fullWidth: false,
    incButtonProps: {},
    value: 0,
    onChange: () => {},
    max: 999,
    minimumQuantity: 1,
    kind: 'primary'
  }

  state = {
    lastPropValue: parseInteger(this.props.value), // last value passed in from props
    lastSetValue: parseInteger(this.props.value), // last value set by onChange
    value: parseInteger(this.props.value), // value displayed in input
    showCTAButton: parseInteger(this.props.value) === 0
  }

  inputId = this.props.id
    ? `${this.props.id}-input`
    : `kds-QuantityStepper-input-${generateUniqueString()}`
  ctaButtonRef = React.createRef()
  incrBtnRef = React.createRef()

  getMinimumQuantity = () => Math.max(1, this.props.minimumQuantity) // minimumQuantity MUST be 1 or more
  isLessThanMinQuantity = value =>
    value > 0 && value < this.getMinimumQuantity()
  isInvalid = value => {
    const isOutOfRange = value < 0 || value > this.props.max

    return isOutOfRange || this.isLessThanMinQuantity(value)
  }

  /* Handle updates to value prop and set value on state */
  static getDerivedStateFromProps (props, state) {
    const newPropValue = parseInteger(props.value)

    if (newPropValue !== state.lastPropValue) {
      const showCTAButton = newPropValue === 0

      return {
        value: newPropValue,
        lastSetValue: newPropValue,
        lastPropValue: newPropValue, // Set specifically for getDerivedStateFromProps
        showCTAButton
      }
    }

    return null
  }

  setValue = (value, snap = false, callback, event) => {
    const { lastSetValue } = this.state
    const { max, onChange } = this.props
    const newValue = snap
      ? snapValue(lastSetValue, value, this.getMinimumQuantity(), max)
      : value
    const showCTAButton = newValue === 0

    event.persist() // required so the 'event' object can be accessed in async callbacks (https://reactjs.org/docs/events.html#event-pooling)

    if (newValue !== lastSetValue) {
      this.setState(
        {
          lastSetValue: newValue,
          value: newValue,
          showCTAButton
        },
        () => {
          onChange(newValue, lastSetValue, event)
          callback && callback()
        }
      )
    } else {
      /*
        snapping value back to an already set value (newValue === lastSetValue)
        we must update 'value' to snapped 'newValue' for the UI
      */
      this.setState({ value: newValue })
    }
  }

  onCTAButtonClick = e => {
    this.setValue(
      this.getMinimumQuantity(),
      true,
      () => focusRef(this.incrBtnRef),
      e
    )
  }

  onDecrementClick = e => {
    this.setValue(
      this.state.value - 1,
      true,
      () => this.state.showCTAButton && focusRef(this.ctaButtonRef),
      e
    )
  }

  onIncrementClick = e => {
    this.setValue(this.state.value + 1, true, null, e)
  }

  onInputKeyDown = e => {
    if (e.key === 'Enter') {
      this.setValue(
        this.state.value,
        null,
        () => this.state.showCTAButton && focusRef(this.ctaButtonRef),
        e
      )
    }
  }

  onInputChange = e => {
    const value = parseInteger(e.target.value)

    this.setState({ value })
  }

  onInputBlur = e => {
    const { value } = this.state

    this.setValue(value, false, null, e)
  }

  render () {
    const { value, showCTAButton } = this.state
    const {
      className,
      compact,
      callToAction,
      callToActionProps,
      decButtonProps,
      description,
      destructive,
      disabled,
      fullWidth,
      incButtonProps,
      what,
      kind,
      max,
      /* The following are destructured to remove from spreadable divProps. */
      children: childrenOmitted, // children not used in this component
      minimumQuantity: minimumQuantityOmitted, // used in various non-render methods
      onChange: onChangeOmitted, // used in various non-render methods
      value: valueOmitted, // used in state constructor and getDerivedStateFromProps,
      /* Remaining props after unneeded ones have been destructured to omit them. */
      ...divProps
    } = this.props
    const { className: callToActionClassName, ...ctaProps } = callToActionProps
    const { className: decButtonClassName, ...decProps } = decButtonProps
    const { className: incButtonClassName, ...incProps } = incButtonProps
    const destructiveDecrement =
      destructive && value <= this.getMinimumQuantity()
    const hideQuantityStepper = callToAction && showCTAButton
    const isInvalid = this.isInvalid(value)
    const disableDecrementBtn = value <= 0 || disabled
    const disableIncrementBtn = value >= max || disabled
    const invalidMessage = isInvalid
      ? this.isLessThanMinQuantity(value)
        ? `${value} is less than the minimum quantity.`
        : `${value} is more than the maximum quantity.`
      : ''
    let rangeLimitMessage = ''

    /** aria-live message for out-of-range values. */
    if (value <= 0) {
      rangeLimitMessage = 'Minimum Quantity Reached,'
    } else if (value >= max) {
      rangeLimitMessage = 'Maximum Quantity Reached,'
    }

    return (
      <div
        {...divProps}
        className={cx('kds-QuantityStepper', className, {
          'kds-QuantityStepper--fullWidth': fullWidth,
          'kds-QuantityStepper--compact': compact,
          'is-disabled': disabled
        })}
        data-testid="kds-QuantityStepper"
      >
        {callToAction && (
          <Button
            aria-label={`${callToAction}: ${what}`}
            className={cx(
              'kds-QuantityStepper-ctaButton',
              {
                'kds-QuantityStepper-ctaButton--hidden': !showCTAButton
              },
              callToActionClassName
            )}
            compact={compact}
            data-testid="kds-QuantityStepper-ctaButton"
            disabled={disabled}
            onClick={this.onCTAButtonClick}
            ref={this.ctaButtonRef}
            kind={kinds.includes(kind) ? kind : undefined}
            {...ctaProps}
          >
            {callToAction}
          </Button>
        )}
        <div
          className={cx('kds-QuantityStepper-wrapper', {
            'kds-QuantityStepper-wrapper--hidden': hideQuantityStepper
          })}
          data-testid="kds-QuantityStepper-wrapper"
          role="group"
        >
          <Button
            aria-label={`${
              destructiveDecrement ? 'Remove' : 'Decrement'
            } ${what}${description ? `, ${description}` : ''}`}
            aria-controls={this.inputId}
            className={cx('kds-QuantityStepper-decButton', decButtonClassName)}
            tabIndex={disableDecrementBtn ? -1 : 0}
            compact={compact}
            data-testid="kds-QuantityStepper-decButton"
            disabled={disableDecrementBtn}
            kind={destructiveDecrement ? 'secondary-negative' : 'cancel'}
            onClick={this.onDecrementClick}
            {...decProps}
          >
            {destructiveDecrement ? <IconTrash /> : <IconMinus />}
          </Button>
          <div
            className="kds-QuantityStepper-inputWrapper"
            data-testid="kds-QuantityStepper-inputWrapper"
          >
            <input
              id={this.inputId}
              aria-invalid={isInvalid}
              aria-live="polite"
              aria-label={`${invalidMessage ||
                rangeLimitMessage ||
                'Quantity of'} ${what}${description ? `, ${description}` : ''}`}
              className={cx('kds-QuantityStepper-input', {
                'kds-QuantityStepper-input--descriptive': description
              })}
              data-testid="kds-QuantityStepper-input"
              disabled={disabled}
              onBlur={this.onInputBlur}
              onChange={this.onInputChange}
              onKeyDown={this.onInputKeyDown}
              aria-valuemax={max}
              max={max}
              aria-valuemin="0"
              min="0"
              type="text"
              inputMode="numeric"
              aria-valuenow={value}
              value={
                /* toString() is necessary to force the browser to strip leading zeros. ¯\_(ツ)_/¯ */
                value.toString()
              }
              style={{
                /* The input is resized to be wide enough for the max value with a little wiggle room */
                width: `${String(max).length}.5ch`
              }}
              tabIndex={
                /* This is required to fix a bug where this button is not perceived as focusable by some versions of VO + Safari. */
                0
              }
            />
            {description && (
              <Text
                aria-hidden="true"
                className="kds-QuantityStepper-description"
                size={compact ? 'xs' : 's'}
              >
                {description}
              </Text>
            )}
          </div>
          <Button
            aria-label={`Increment ${what}${
              description ? `, ${description}` : ''
            }`}
            aria-controls={this.inputId}
            className={cx('kds-QuantityStepper-incButton', incButtonClassName)}
            tabIndex={disableIncrementBtn ? -1 : 0}
            ref={this.incrBtnRef}
            compact={compact}
            data-testid="kds-QuantityStepper-incButton"
            disabled={disableIncrementBtn}
            onClick={this.onIncrementClick}
            {...incProps}
          >
            <IconPlus />
          </Button>
        </div>
      </div>
    )
  }
}

export default QuantityStepper
