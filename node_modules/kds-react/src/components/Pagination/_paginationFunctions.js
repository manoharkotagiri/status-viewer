import ReactDOM from 'react-dom'

/* Maximum number of links to displayed */
const maxNumberOfLinks = 10

/* Capture focus on nearest link when previous/next page buttons are disabled while they have focus */
export function captureFocusAfterDisablingButton (buttonRef) {
  const el = ReactDOM.findDOMNode(buttonRef.current)

  setTimeout(() => {
    const lostFocus = el !== document.activeElement

    if (lostFocus) {
      const nextFocusEl = el.nextElementSibling || el.previousElementSibling
      nextFocusEl.focus()
    }
  })
}

/*
  - enforce odd number of links between left/right ellipsis by removing one of the links
  - enforce 2 page skip for showing teh ellipsis only when makes sense, if only one page is skipped inject page back into array
*/
export function normalizePageLinks (pageLinks) {
  const [firstLinkPage, secondLinkPage] = pageLinks
  const [linkBeforeLastPage, lastLinkPage] = pageLinks.slice(-2)
  const leftSinglePageSkip = secondLinkPage - firstLinkPage === 2
  const rightSinglePageSkip = lastLinkPage - linkBeforeLastPage === 2
  const leftEllipse = secondLinkPage - firstLinkPage > 2
  const rightEllipse = lastLinkPage - linkBeforeLastPage > 2
  const middleLinksEven = pageLinks.slice(1, -1).length % 2 === 0

  /* inject link back into array if only one page was skipped on the left */
  if (leftSinglePageSkip) {
    /* only inject if there is enough room */
    if (pageLinks.length < maxNumberOfLinks) {
      pageLinks = [
        ...pageLinks.slice(0, 1),
        firstLinkPage + 1,
        ...pageLinks.slice(1)
      ]
    } else {
      /* else remove a link to make the gap 2 wide */
      pageLinks = [...pageLinks.slice(0, 1), ...pageLinks.slice(2)]
    }
  }

  /* inject link back into array if only one page was skipped on the right */
  if (rightSinglePageSkip) {
    /* only inject if there is enough room */
    if (pageLinks.length < maxNumberOfLinks) {
      pageLinks = [
        ...pageLinks.slice(0, -1),
        linkBeforeLastPage + 1,
        ...pageLinks.slice(-1)
      ]
    } else {
      /* else remove a link to make the gap 2 wide */
      pageLinks = [...pageLinks.slice(0, -2), ...pageLinks.slice(-1)]
    }
  }

  /* keep middle links odd by removing first middle link when there is an even number of links between left/right ellipsis */
  if (leftEllipse && rightEllipse && middleLinksEven) {
    pageLinks = [...pageLinks.slice(0, 1), ...pageLinks.slice(2)]
  }

  return pageLinks
}

/* Generate array of page numbers to render links for, always showing current link */
export function generateVisiblePageLinks (
  numberOfPages,
  numberOfDisplayedPages,
  currentPage
) {
  /* Default to only show current page number */
  let pageLinks = [currentPage]
  numberOfDisplayedPages = Math.min(numberOfPages || 1, numberOfDisplayedPages)

  /* Only display multiple page links when number of pages are defined */
  if (
    numberOfPages &&
    numberOfDisplayedPages > 1
    /* Cannot display 2 links with ellipsis, instead force to display 1 link */
    // !(numberOfDisplayedPages === 2 && numberOfPages > 2)
  ) {
    /* Number of links visible between the first and last page links */
    const middleLinks =
      numberOfDisplayedPages >= 3
        ? numberOfDisplayedPages - 2
        : numberOfDisplayedPages
    /* Half the number of displayed links */
    const halfOfLinks = parseInt(numberOfDisplayedPages / 2)
    /* Reference point to begin/end hiding links to the left of current page (left ellipsis) */
    const leftExtrema = 1 + halfOfLinks
    /* Reference point hiding links to the right of current page (right ellipsis) */
    const rightExtrema = numberOfPages - halfOfLinks

    pageLinks = [...Array(numberOfDisplayedPages)].map((_, i) => {
      let page

      /* Always show first page on the left */
      if (i === 0) {
        page = 1
      } else if (i === numberOfDisplayedPages - 1) {
        /* Always show last page on the right */
        page = numberOfPages
      } else if (currentPage <= leftExtrema) {
        /* Compute remaining page links sequentially from left (no left ellipsis) */
        page = i + 1
      } else if (currentPage > leftExtrema && currentPage < rightExtrema) {
        /* Compute remaining page links sequentially with current page being the median (current page remains centered, potential left & right ellipsis) */
        page = i + currentPage - parseInt(middleLinks / 2) - 1
      } else if (currentPage >= rightExtrema) {
        /* Compute remaining page links sequentially from right (no right ellipsis) */
        page = i + numberOfPages - middleLinks - 1
      }

      return page
    })
  }

  return pageLinks
}

/* Get number of links that can safely fit on a single line in the allotted space */
export function getNumberOfDisplayedPageLinks (
  numberOfPages,
  containerWidth,
  buttonWidth
) {
  /* Estimated width of single link (~charWidth * chars + ~margin) */
  const maxLinkSize = String(numberOfPages || 0).length * 10 + 50
  /* Remaining width for links (containerWidth - ~buttonWidthX2) */
  const spaceForLinks = containerWidth - buttonWidth * 2
  /* Maximum number of links that can fit in the space alotted */
  const maxNumberOfLinksThatFit = parseInt(spaceForLinks / maxLinkSize) || 1
  /* Links to display, showing no more than layout allows, consumer limit, or totals pages existing */
  const numberOflinks = Math.min(
    numberOfPages || 1,
    maxNumberOfLinks,
    maxNumberOfLinksThatFit
  )

  /* Cannot display 2 links with ellipsis, instead force to display 1 link */
  return numberOflinks === 2 && numberOfPages > 2 ? 1 : numberOflinks
}
