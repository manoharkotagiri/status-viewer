import cx from 'classnames'
import PropTypes from 'prop-types'
import React, { useState, useEffect, useRef } from 'react'
import { withRouter as withReactRouter } from 'react-router-dom'
import Button from '../Button/Button'
import Link from '../Link/Link'
import { IconCaretLeft, IconCaretRight, IconEllipsis } from '../Icon'
import { callSafely } from '../../utils/functionUtils'
import { getWindow } from '../../utils/windowUtils'
import useOnResize from '../../hooks/useOnResize'
import {
  generateVisiblePageLinks,
  captureFocusAfterDisablingButton,
  getNumberOfDisplayedPageLinks,
  normalizePageLinks
} from './_paginationFunctions'

/**
 * Pagination provides an interface for users to navigate multiple pages of content
 *
 * Pagination will attempt to 'display' as many page links as it can fit (up to 10) on one line,
 * responsively hiding any 'extra' links that cannot fit.
 * **/
const PaginationComponent = ({
  className,
  maxNumberOfDisplayedPages,
  numberOfPages,
  forcePage,
  onPageChange,
  hrefBuilder,
  disableNextButton,
  withRouter,
  history,
  ...props
}) => {
  const [currentPage, setCurrentPage] = useState(1)
  const [numberOfDisplayedPages, setNumberOfDisplayedPages] = useState(1)
  const pagination = useRef()
  const prevButton = useRef()
  const nextButton = useRef()
  const pageLinks = normalizePageLinks(
    generateVisiblePageLinks(numberOfPages, numberOfDisplayedPages, currentPage)
  )

  useOnResize({ onResize: setLinks, debounceDuration: 200 })

  useEffect(setLinks, [])

  useEffect(() => {
    if (forcePage) {
      setPage(forcePage)
    }
  }, [forcePage])

  function setPage (page) {
    /* Snap page within range of valid pages, 1 to (numberOfPages or Infinity) */
    const clampedPage = numberOfPages
      ? Math.min(numberOfPages, Math.max(1, page))
      : Math.max(1, page)

    setCurrentPage(clampedPage)
  }

  function changePage (page, e) {
    callSafely(onPageChange)(page, e)
    setPage(page)
  }

  function navigateToPage (page, e) {
    const { location } = getWindow()
    const href = callSafely(hrefBuilder)(page)

    if (!e.defaultPrevented) {
      if (withRouter && history) {
        history.push(href)
      } else if (location) {
        location.assign(href)
      }
    }
  }

  function setLinks () {
    if (pagination.current) {
      /* Total space the links are able to occupy, uses parent container width does not factor in padding */
      const containerWidth = pagination.current.parentNode.getBoundingClientRect()
        .width
      /* Width of the prev/next button */
      const buttonWidth = prevButton.current
        ? prevButton.current.getBoundingClientRect().width
        : 32
      const numberOflinks = getNumberOfDisplayedPageLinks(
        numberOfPages,
        containerWidth,
        buttonWidth
      )

      setNumberOfDisplayedPages(numberOflinks)
    }
  }

  return (
    <nav
      ref={pagination}
      aria-label="Pagination"
      className={cx('kds-Pagination', 'justify-center', className)}
      {...props}
    >
      <Button
        ref={prevButton}
        className="kds-Pagination-prev"
        aria-label="Previous page"
        kind="tertiary"
        compact
        disabled={currentPage <= 1}
        onClick={e => {
          const prevPage = currentPage - 1

          changePage(prevPage, e)
          navigateToPage(prevPage, e)
          captureFocusAfterDisablingButton(prevButton)
        }}
      >
        <IconCaretLeft />
      </Button>
      {pageLinks.reduce((acc, page, i) => {
        const isCurrentPage = currentPage === page
        /* Only show overlay when multiple pages are visible */
        const showCurrentPageOverlay = isCurrentPage && pageLinks.length > 1
        /* Distance between adjacent page links */
        const pageLinkGap = pageLinks[i + 1] - page
        /* Show ellipsis when 'multiple' pages are skipped */
        const appendEllipsis = pageLinkGap > 1

        return [
          ...acc,
          <Link
            key={page}
            className="kds-Pagination-link"
            aria-current={isCurrentPage ? 'page' : null}
            aria-label={`Page ${page}`}
            inverse={showCurrentPageOverlay}
            onClick={e => changePage(page, e)}
            href={callSafely(hrefBuilder)(page)}
            withRouter={withRouter}
            implied
          >
            {page}
          </Link>,
          appendEllipsis && (
            <IconEllipsis
              key={`${page}-ellipsis`}
              className="kds-Pagination-ellipsis"
            />
          )
        ]
      }, [])}
      <Button
        ref={nextButton}
        className="kds-Pagination-next"
        aria-label="Next page"
        kind="tertiary"
        compact
        disabled={
          numberOfPages ? currentPage >= numberOfPages : disableNextButton
        }
        onClick={e => {
          const nextPage = currentPage + 1

          changePage(nextPage, e)
          navigateToPage(nextPage, e)
          captureFocusAfterDisablingButton(nextButton)
        }}
      >
        <IconCaretRight />
      </Button>
    </nav>
  )
}

const Pagination = props => {
  if (props.withRouter) {
    const PaginationWithRouter = withReactRouter(PaginationComponent)

    return <PaginationWithRouter {...props} />
  } else {
    return <PaginationComponent {...props} />
  }
}

Pagination.propTypes = {
  /**
   * The number of pages for the paginated data. If number of pages are not provided only the current page link will be displayed along with previous/next page buttons.
   **/
  numberOfPages: PropTypes.number,
  /**
   * Used to explicitly disable the next page button when unable to provide `numberOfPages` to inform component when there is no next page.
   **/
  disableNextButton: PropTypes.bool,
  /**
   * Callback invoked when the page changes. Arguments provided are: 'page' (1 based index) and 'event'.
   **/
  onPageChange: PropTypes.func,
  /**
   * Function used to build href for each page link.
   **/
  hrefBuilder: PropTypes.func.isRequired,
  /**
   * Set to `true` if you want to use React Router for navigation
   **/
  withRouter: PropTypes.bool,
  /**
   * Set the current page, page number is 1 based index.
   **/
  forcePage: PropTypes.bool
}

Pagination.defaultProps = {
  disableNextButton: false,
  withRouter: false
}

export default React.memo(Pagination)
